{"meta":{"title":"Misaka mikoto","subtitle":"CLANNAD","description":"simple description : yesterday I dream you again","author":"Rhymeet Liu","url":"http://rhymeet.github.io","root":"/"},"pages":[{"title":"404","date":"2022-09-15T13:02:08.000Z","updated":"2022-09-15T13:04:57.637Z","comments":true,"path":"404/index.html","permalink":"http://rhymeet.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-09-15T12:48:10.000Z","updated":"2022-09-15T12:59:53.453Z","comments":true,"path":"categories/index.html","permalink":"http://rhymeet.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-09-15T12:50:03.000Z","updated":"2022-09-15T12:53:17.599Z","comments":true,"path":"about/index.html","permalink":"http://rhymeet.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-15T12:49:51.000Z","updated":"2022-09-15T13:00:58.809Z","comments":true,"path":"tags/index.html","permalink":"http://rhymeet.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-09-15T12:50:59.000Z","updated":"2022-09-15T12:56:55.203Z","comments":true,"path":"friends/index.html","permalink":"http://rhymeet.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-09-15T12:50:44.000Z","updated":"2022-09-15T13:00:27.216Z","comments":true,"path":"contact/index.html","permalink":"http://rhymeet.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"CET6","slug":"CET6","date":"2022-11-09T13:55:17.000Z","updated":"2022-11-09T13:56:07.761Z","comments":true,"path":"2022/11/09/CET6/","link":"","permalink":"http://rhymeet.github.io/2022/11/09/CET6/","excerpt":"","text":"","categories":[{"name":"English","slug":"English","permalink":"http://rhymeet.github.io/categories/English/"}],"tags":[]},{"title":"relate_words","slug":"relate-words","date":"2022-11-09T13:54:41.000Z","updated":"2022-11-10T14:56:47.495Z","comments":true,"path":"2022/11/09/relate-words/","link":"","permalink":"http://rhymeet.github.io/2022/11/09/relate-words/","excerpt":"","text":"# semaphore /ˈseməˌfôr/ 名词：信号，旗语，臂板信号，信号机 binary semaphore 二进制信号量 # simultaneously 同时地 # exclusive 独有的、专用的、排外的、排斥的 # synchronization 同步 # mutel exclusion within the monitor 监视器内的互斥排除 # monitor 管程","categories":[{"name":"English","slug":"English","permalink":"http://rhymeet.github.io/categories/English/"}],"tags":[]},{"title":"OS(三)内存管理","slug":"OS-三-内存管理","date":"2022-11-09T11:56:48.000Z","updated":"2022-11-09T12:00:04.731Z","comments":true,"path":"2022/11/09/OS-三-内存管理/","link":"","permalink":"http://rhymeet.github.io/2022/11/09/OS-%E4%B8%89-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"","categories":[{"name":"OS","slug":"OS","permalink":"http://rhymeet.github.io/categories/OS/"}],"tags":[]},{"title":"Kmeans","slug":"Kmeans","date":"2022-11-07T01:12:46.000Z","updated":"2022-11-07T01:12:46.869Z","comments":true,"path":"2022/11/07/Kmeans/","link":"","permalink":"http://rhymeet.github.io/2022/11/07/Kmeans/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"VIF","slug":"VIF","date":"2022-11-07T01:12:20.000Z","updated":"2022-11-07T01:12:20.996Z","comments":true,"path":"2022/11/07/VIF/","link":"","permalink":"http://rhymeet.github.io/2022/11/07/VIF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"4_mul_linerRegression","slug":"4-mul-linerRegression","date":"2022-11-07T01:11:48.000Z","updated":"2022-11-07T01:11:48.478Z","comments":true,"path":"2022/11/07/4-mul-linerRegression/","link":"","permalink":"http://rhymeet.github.io/2022/11/07/4-mul-linerRegression/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"OS(二)进程与线程","slug":"OS-二-进程与线程","date":"2022-11-03T09:12:47.000Z","updated":"2022-11-13T14:57:55.076Z","comments":true,"path":"2022/11/03/OS-二-进程与线程/","link":"","permalink":"http://rhymeet.github.io/2022/11/03/OS-%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"# 进程の状态与转换 # 状态 # 创建态、就绪态 进程正在被创建时，它的状态是 “创建态”，在这个阶段操作系统会为进程 分配资源，初始化 PCB 当进程创建完成后，便进入 “就绪态”，处于就绪态の进程已经具备运行条件，但由于没有空闲の CPU，就暂时不能运行 # 运行态 如果一个进程此时在 CPU 上运行，那么这个进程称处于 “运行态” CPU 会执行该进程对应の程序 (执行指令序列) # 阻塞态 在进程运行过程中，可能会请求等待某个事件的发生 (如等待某种系统资源の分配 or 等待其他进程的响应) 让这个进程下 CPU ，并让它进入 &quot; 阻塞态 &quot; 当 CPU 空闲时，又会选择另一个 “就绪态” 进程上 CPU 运行 # 终止态 该进程可执行 exit 系统调用，请求操作系统终止该进程 此时该进程会进入 “终止态”，操作系统会让该进程下 CPU 并回收内存空间等资源，最后还要回收该进程的 PCB。 当终止进程的工作完成后，这个进程彻底消失了 # 状态间の转换 进程 PCB 中，会有一个变量 state 来表示进程的当前状态 # 进程的组织方式 # 进程控制 # 基本概念 WHAT： 进程控制的主要功能是对系统中所有进程 实施有效的管理，具有创建新进程、策划小已有新进程、实现进程状态转换等功能 实现进程状态的转换 如何实现：用原语实现 原语 是一种特殊的程序，它的执行具有原子性。 # 进程控制相关的原语 Tip：无论哪个进程控制原语，要做的就三件事 更新 PCB 中信息 (修改进程状态 state) 保存 / 恢复运行环境 所有的进程控制原语一定都会会修改进程状态标志 录夺当前运行进程的 CPU 使用权 必然需保存其运行环境 某些进程开始运行前必然要恢复其运行环境 将 PCB 插入合适的队列 分配 / 回收资源 # 进程的创建 # 进程的终止 # 进程的阻塞 # 进程的唤醒 # 进程的切换 # 进程通信 (IPC) Inter-process Communication 两个进程之间产生 数据交互 进程 是分配系统资源的单位 (include 内存地址空间)，因此各进程拥有的内存地址空间相互独立 为保证安全，一个进程不能直接访问另一个进程的地址空间 # 共享存储 为避免出错，各个进程对共享空间的访问应该是互斥的 各个进程可使用 OS 内核提供的同步互斥工具 (PV 操作) 基于数据结构的共享 比如共享空间里只能放一个长度为 10 的数组。这种通信方式速度慢、限制多、是一种低级通信方式 基于存储区的共享 OS 在内存中划出一块共享存储区，数据的形式、存放位置都由通讯进程控制，而不是 OS。这种共享方式速度很快，是一种高级通讯方式 # 消息传递 进程间的数据交换以格式化的消息 (Message) 为单位 进程通过 OS 提供的 “发送消息 / 接收消息” 两个原语进行数据交换 直接通信方式 消息发送进程要指明 接收进程的 ID 间接通信方式 通过 “信箱” 作为中间实体进行消息传递 # 管道通信 管道是一个特殊的共享文件，又名 pipe 文件。其实就是在内存中开辟一个大小固定的内存缓冲区 写进程往管道写数据，即使管道没被写满，只要管道没空，读进程就可以从管道中读数据 都进程从管道中读数据，即使管道没被读空，只要管道没满，写进程就可以往管道中写数据 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道 各进程要互斥地访问管道 (由操作系统实现) 当管道写满时，写进程将阻塞，直到都进程将 管道中的数据取走，即可唤醒写进程 当管道读空时，读进程将阻塞，直到写进程往 管道中写入数据，即可唤醒读进程 管道中的数据一旦被读出，就彻底消失。 SO，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案： 一个管道允许多个写进程，一个读进程 (14 年官方答案) 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据 (Linux の方案) # 线程概念、多线程模型 可以把线程理解为 “轻量级进程” 线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位。 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内使得一个进程内也可以并发处理各种任务 (如 tim 视频、文字聊天、传文件) 引入线程后，进程只作为除 COU 之外的系统资源的分配单元 (如 打印机、内存地址空间等 都是分配给进程的) 线程则作为处理机的分配单元 # 变化 资源分配、调度 传统进程机制中，进程是 资源分配、调度的基本单位 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位 并发性 传统进程机制中，只能进程之间并发 引入线程后，各线程间也能并发，进程间也并发，提高了并发度 系统开销 传统进程间并发，需要切换进程的运行环境，系统开销很大 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小 引入线程后，并发所带来的系统开销小 # 属性 线程是处理机调度的单位 多 CPU 计算机中，各个线程可占用不同的 CPU 每个线程都有一个线程 ID 、线程控制块 (TCB) 线程也有 就绪、阻塞、运行 三种基本状态 线程几乎不拥有系统资源 同一进程の 不同线程间共享 进程の资源 由于共享内存地址空间，同一进程中の线程间通信甚至无需系统干预 同一进程间の线程切换 不会引起进程切换 不同进程中の线程切换 会引起进程切换 切换同进程内の线程，系统开销很小 切换进程，系统开销很大 # 线程的实现方式 &amp; 多线程模型 # 线程的实现方式 # 用户级线程 用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责 (包括 线程切换) 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预 在用户看来，是由多个线程。但是在操作系统内核看来，并 意识不到线程の存在。 “用户级线程” 就是 “从用户视角能看到の线程” 优缺点： 优点：用户级线程の切换 在用户空间即可完成，不需要切换到核心态，线程管理の系统开销小，效率高。 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。 多个线程不可在多核处理机上并行运行。 # 内核级线程 内核级线程の管理工作由操作系统内核完成 线程调度、切换等工作都由内核负责，so 内核级线程の切换必然需要在核心态下才能完成 操作系统 会为每个 内核级线程建立相应的 TCB (Thread control Block 线程控制块)，通过 TCB 对线程进行管理。“内核级线程” 就是 “从操作系统内核视角看 能看得到的线程” 优缺点： 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。 多线程可在多核处理机上并发执行。 缺点：一个用户会占用多个内核级线程，线程切换由 OS 内核完成，需要切换到核心态，so 线程管理の成本高，开销大。 # 多线程模型 在支持内核级线程的系统中，根据用户级线程 and 内核级线程 の映射关系，可以划分为几种多线程模型 # 一对一模型 一个用户级线程 映射到 一个内核级线程。每个用户进程有与 用户级线程同数量の内核级线程 优点： # 多对一模型 # 多对多模型 # 线程的状态与转换 # 状态与转换 # 组织与控制 # 调度算法 Tips 作业调度 or 进程调度？ 抢占式 or 非抢占式？ 优缺点？是否导致饥饿？ # 先来先服务 (FCFS) # 短作业优先 (SJF) # 高响应比优先 (HRRN) ！ 😂 算法 可抢占？ 优点 缺点 考虑等待时间、运行时间 饥饿？ (某进程长期得不到服务) FCFS 非抢占式 公平；实现简单 对短作业不利、长作业有利 等待时间 不会 SJF/SPF 默认非抢占式 SJF/SPF 、抢占式 SRTN 拥有最短の平均等待时间、平均周转时间 对长作业不利、可能导致饥饿；难以做到真正の短作业优先 运行时间 会 HRRN 非抢占式 FCFS &amp; SJF の折中 😵 综合考虑等待时间、运行时间 不会 SJF/SPF 可用于 作业调度 job、进程调度 process 作业 / 进程の运行是由用户提供的，并不一定真实，不一定能做到真正的短作业优先 S Remaining Time Next # 调度の层次、概念 作业：一个具体の任务 用户向系统提交一个作业～用户让 OS 启动一个程序 (来处理一个具体の任务) 挂起： 内存不够时，可将某些进程の数据调出外存。等 内存空闲 or 进程需要 运行时再重新调入内存。 暂时调到外存等待の进程状态 为 挂起状态。被挂起的进程 PCB 会被组织成挂起队列。 挂起态可分为：就绪挂起、阻塞挂起。 有的 OS 会把 就绪挂起、阻塞挂起 分为两个挂起队列，甚至会根据阻塞原因不同再把 阻塞挂起进一步细分为多个队列 # 三个层次 高级调度 (作业调度): 外存 ---&gt; 内存 按照某种规则，从后备队列中选择合适の作业将其调入内存，并为其创建进程。 按一定的原则从 外存の作业后备队列中挑选一个作业 调入内存，并创建进程。 每个作业值调入一次，调出一次。 作业调入时 会创建 PCB，调出时 才撤销 PCB。 低级调度 (进程调度 / 处理机调度)： 内存 ---&gt;CPU 按照某种规则，从就绪队列中选择一个进程为其分配处理机。 按照某种策略 从就绪队列中选取 一个进程，将处理机分配给它。 是 OS 中最基本の一种调度，在一般の OS 中都必须配置 进程调度。 进程调度の 频率很高，一般几十毫秒一次 中级调度 (内存调度)： 外存 ---&gt; 内存 按照某种规则，从挂起队列中选择合适的进程 将其数据调回内存 按照某种策略决定将哪个处于挂起状态の进程重新调入内存。 一个进程可能会被 多次调出、调入内存，因此中极调度 发生の频率要比高级调度更高。 # 进程互斥の软件实现方法 # 单标志法 算法思想：两个进程在访问完临界区后会把使用临界区の权限 转交给另一个进程。 = 每个进程进入临界区の权限只能由另一个进程赋予 “同一时刻最多只允许一个进程访问临界区” 未遵循 “空闲让进” # 双标志先检查 未遵循 “忙则等待” (p0,p1 搞不好同时访问临界区) # 双标志后检查 未遵循 “空闲让进 、 有限等待” ，可能导致饥饿 # Peterson 算法 遵循了 空闲让近、忙则等待、有限等待 三个原则，but 依未遵循 让权等待 原则 # 进程互斥の硬件实现方法 # 中断屏蔽方法 利用 “开 / 关中断指令” 实现 (与原语的实现思想相同，即 在某进程开始访问临近区到结束访问为止都不允许被中断，也就不能发生进程切换， 因此也不能发生两个同时 访问临界区的情况) 关中断； 临界区； 开中断； 优点：简单、高效 缺点：不适用于 多处理机；只适用于操作系统内核进程，不适用于 用户进程 (因为 开 / 关 中断指令只能运行在内核态， 这组指令如果能让用户随意使用会很危险) # TestAndSet 指令 简称 TS、TSL 指令 TSL 是用硬件实现的，执行过程中不允许被中断，只能一气呵成。 优点：适用于多处理机环境 实现简单、无需像软件方法严格检查是否有漏洞 缺点：不满足” 让权等待 “原则，暂时无法进入临界区の进程会占用 CPU 并循环执行 TSL 指令，从而导致 “忙等” # Swap 指令 简称 Exchange XCHG 指令 Swap 指令是用硬件实现の，执行过程中不允许被中断，只能一气呵成。 优点：适用于多处理机环境 实现简单、无需像软件方法严格检查是否有漏洞 缺点：不满足” 让权等待 “原则，暂时无法进入临界区の进程会占用 CPU 并循环执行 TSL 指令，从而导致 “忙等” # 互斥锁 解决临界区最简单工具の就是互斥锁 (mutex lock) . 一个进程在进入临界区时应获得锁；在退出临界区时释放锁。 函数 acquire () 获得🔒，release () 释放🔒。 每个互斥锁有一个布尔变量 availabel, 表示🔒是否可用。 如果🔒是可用の，调用 acquire () 会成功，且🔒不再可用。当一个进程试图获取不可用的🔒时，会被阻塞，直到🔒被释放。 acquire() while(!available)&#123; ； //忙等待 available = false; //获得锁 &#125; release()&#123; available = true; //释放锁 &#125; acquire () 和 release () 的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。 互斥锁の主要缺点是忙等待，当有一个进程在临界区，任何其他进程在进入临界区时必须连续循环调用 acquire () 当多个进程共享同一 CPU 时，就浪费了 CPU の生命周期。 因此，互斥锁 通常用于多处理系统，一个线程可以在一个处理器上等待，不影响其他线程の执行。 需要连续循环忙等的互斥锁，都可称为自旋锁 (spin lock), 如 TSL、swap、单标志法 特性： 需忙等，进程时间片用完才下 处理机，违反 “让权等待” 优点：等待期间不用切换上下文，多处理系统中，若上锁の时间短，则等待代价很低 常用于多处理系统，一个核忙等，其他核正常工作，并快速释放临界区 不太适用于单处理机系统，忙等の过程中不可能照常工作 # 信号量机制 1965，荷兰科学家 Dijkstra 提出の实现 “进程互斥、同步の方法”-- 信号量机制 用户进程可以通过使用 OS 提供の一对原语来对信号量进行操作，实现了进程互斥、进程同步。 每个信号量至少记录 2 个信息：信号量的值 and 等待该信号量的进程队列 (queue PCB) (类 PASCAL 语言来描述) semaphore = record value: integer; queue: ^PCB; end; 其中 PCB 是进程控制块，是操作系统为每个进程建立的数据结构。 信号量其实就是一个变量，一个信号量可 表示系统中某种资源の数量，如：系统中只有一台打印机，就可以设置一个处置为 1 的信号量。 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断 / 开中断指令实现的。 一对原语：wait (S) 原语 &amp; signal (S) 原语，原语可理解为自己写的函数，信号量 S 为函数调用时传入の参数。 wait、signal 原语常简称为 P、V 操作。平时常写为 P (S)、V (S) # 整型信号量 用一个整数型变量作为信号量，用来表示系统中某种资源的数量。 与普通整数信号量の区别：对信号量的操作只有三种：初始化、P 操作、V 操作 Eg：某计算机系统有一台打印机 int S = 1; //初始化整形信号量，表示打印机资源个数 void wait(int S)&#123; //wait原语，相当于“ 进入区” while( S &lt;=0 ); S = S - 1; &#125; void signal(int S)&#123; //signal原语，相当于“ 退出区” S = S + 1; &#125; 进程 pi ... wait (s); // 进入区，申请资源 使用资源... // 临界区，访问资源 signal (s); // 退出区，释放资源 ... # 记录型信号量 整型信号量缺陷 存在 “忙等” 问题，-&gt;, 记录型 数据结构表示の信号量。 信号量 value&gt;0，value 表示可用资源的数量；value&lt;0，value 表示因该类资源阻塞的进程数量。 // 记录型信号量の定义 typedef struct { int value; // 剩余资源数 struct process *L; // 等待队列 } semaphore; void wait( semaphore S)&#123; S.value--; if(S.value &lt; 0)&#123; block(S.L); //如果剩余资源数不够，使用block原语使进程 运行态-&gt;阻塞态，并把挂到信号量S的等待(阻塞)队列中 &#125; &#125; void singal( semaphore S)&#123; S.value++; if(S.value &lt;= 0)&#123; wakeup(S.L); //释放资源后，若还有别的进程在等待这个资源，则使用wakeuo原语唤醒等待队列中的一个进程，该进程从 阻塞态-&gt;就绪态 &#125; &#125; P 操作 S.value &lt;0 该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞，主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了 &quot;让权等待&quot; 原则，不会出现 “忙等” 现象。 # 二进制信号量 (Binary Semaphore) 只允许信号量取 0 or 1 值 # 用信号量机制实现进程 互斥、同步、前驱关系 一个信号量对应一种资源 信号量的值 = 这种资源的剩余数量 (信号量值 &lt; 0, 说明此时有进程在等待这种资源) P (S)-- 申请一个资源 S，若资源不够就阻塞等待 V (S)-- 释放一个资源 S，若有进程在等待这个资源，则唤醒一个进程 # 进程互斥 basic：信号量 mutex 表示 “进入临界区的名额” 分析并发进程的关键活动，划定临界区 设置互斥信号量 mutex, 初值为 1 在进入区 P (mutex)-- 申请资源 在退出区 V (mutex)-- 释放资源 注意：对不同的临界资源需要设置不同的互斥信号量 缺少 P (mutex) 就不能保证临界资源的互斥访问 缺少 V (mutex) 会导致资源永不被释放，等待进程永不被唤醒 //记录型信号量の定义 typedef struct&#123; int value; //剩余资源数 struct process *L; //等待队列 &#125;semaphore; //信号量机制实现互斥 semaphore mutex = 1; P1()&#123; ... P(mutex); //使用临界资源要加锁 临界区代码段... V(mutex); //解锁 ... &#125; P2()&#123; ... P(mutex); 临界区代码段... V(mutex); ... &#125; # 进程同步 要让各并发进程 按要求有序地推进 分析什么地方需要实现 “同步关系”，即必须保证 “一前一后” 执行的两个操作 (or 代码) 设置同步信号量 S，初值为 0 在 “前操作” 之后执行 V (S) 在 “后操作” 之前执行 P (S) # 进程前驱关系 要为每一对前驱关系各设置一个同步信号量 在 “前操作” 之后对相应的同步信号量执行 V 操作 在 “后操作” 之前对相应的同步信号两执行 P 操作 # 生产者消费者问题 # 多生产者 - 多消费者 # 吸烟者问题 # 读者写者问题 mutex (1):a semaphore which is used to ensure mutual exclusion when readcount is updated i.e. when any reader enters or exits from the critical section. 一个信号量，用于在 readcount 更新时确保互斥，即当任何阅读器进入或退出临界区时。 readcount (0): an integer variable that keeps track of how many processes are currently reading the object. 跟踪当前有多少进程正在读取对象 wrt (1):a semaphore common to both reder and writer process. # 哲学家进餐问题 Declare condition self[5]; Allows philosopher i to delay when he is hungery but is unable to obtain chopsticks needed. # 管程 # 引入管程原因 解决信号量机制存在的问题：编写程序困难、易出错 一种机制，让程序员写程序时不需再关注复杂的 PV 操作 1973 年，Brinch Hansen 首次再程序设计语言 (Pascal) 中引入 “管程” 成分 -- 一种高级同步机制 # 管程的定义和基本特征 管程是一种特殊的软件模块，有这些部分组成： 局部于管程的 共享数据结构说明 对该数据结构进行操作的一组过程 对局部于管程的共享数据设置初始值的语句 管程有一个名字 # # 死锁的概念 哲学家问题中，if 5 个哲学家都拿起了走手边的筷子。 每个人都占有资源，同时又在等待另一个人手里的资源 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象 # 死锁、饥饿、死循环 死锁：一定是 “循环等待对方手里的资源” 导致的，因此如果有死锁现象，那么至少有两个 or 两个以上的进程同时发生死锁. 发生死锁的进程一定处于阻塞态。 饥饿：可能只有一个进程发生饥饿。可能是阻塞态 or 就绪态、(长期得不到需要的 I/O 设备、长期得不到处理机)","categories":[{"name":"OS","slug":"OS","permalink":"http://rhymeet.github.io/categories/OS/"}],"tags":[]},{"title":"SQL(二) 关系数据库","slug":"SQL-二-关系数据库","date":"2022-11-02T10:12:31.000Z","updated":"2022-11-09T11:37:17.386Z","comments":true,"path":"2022/11/02/SQL-二-关系数据库/","link":"","permalink":"http://rhymeet.github.io/2022/11/02/SQL-%E4%BA%8C-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"简介：提出关系模型的是美国 IBM 公司的 E.F.Codd 1970 年提出关系数据模型 after , 提出了关系代数 and 关系演算的概念 1972 提出了关系的 第一、第二、第三范式 1974 提出了关系的 BC 范式 # 关系数据结构及形式化定义 # 关系 关系 ：单一的数据结构 。 现实世界的实体 及 实体间的各种联系均用关系来表示。 二维表 ： 逻辑结构。 从用户角度，关系模型中的数据结构 是一张二维表。 建立在集合代数的基础上。 Syntax Description 域 (Domain) 一组具有相同数据类型的集合 笛卡尔积 (Cartesian Product) 所有域所有取值的一个组合 ；不能重复 关系 (Relation) # 域 (Domain) # 一组具有相同数据类型的集合 # 笛卡尔积 (Cartesian Product) from itertools import product for x,y,z in product(['a','b','c'],['d','e','f'],['m','n']): print(x,y,z) 元组 (Tuple) 笛卡尔积中每一元素 (d1,d2,...,dn) 叫做一个 n 元组 (n-tuple) or 简称元组 (张青梅，计算机专业，李勇) 分量 (Component) 笛卡尔积元素 (d1,d2,...,dn) 中的每一个值 di 叫做一个分量。 张青梅、计算机专业、... 基数 (Cardinal number) 笛卡尔积的表示方法 可 一个二维表 每行对应一个元组，每列对应一个域 # 关系 (Relation) # 关系 # 元组 关系中的每个元素是关系中的元组，通常用 t 表示。 # 单元关系 与 二元关系 n=1, 单元关系 (Unary relation) or 一元关系 n=2, 二元关系 (Binary relation) # 关系的表示 关系也是一个二维表，每行对应一个元组，每列对用一个域 # 属性 关系中不同列可对应相同的域 为区分，必须对每列起一个名字，成为属性 n 目关系必有 n 个属性 # 码 候选码 (Candidate Key) 若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码 简单的情况：候选码只包含一个属性 全码 (All-key) 最极端的情况：关系模式中的所有属性组是这个关系模式的候选码，成为全码。 主码 若一个关系有多个候选码，则选定其中一个为主码 (Primary key) 主属性 候选码的诸属性成为主属性 (Prime attribute) 不包含任何候选码的属性成为非主属性 (None-Prime attribute) or 非码属性 # 三类关系 基本关系 (基本表 or 基表): 实际存在的表，是实际存储数据的逻辑表示。 查询表：查询结果对应的表。 视图表：是虚表，由基本表 or 其他试图表导出的表，不对应实际存储的数据。 # 基本关系的性质 列是同质的 (Homogeneous) 不同的列可出自同一个域 其中的每一列称为一个属性 不同的属性要给予不同的属性名 列的顺序无所谓，列的次序可任意交换。 行的顺序无所谓，行的次序可以任意交换。 任意两个元组的候选码不能相同 分量必须取原子值（most basic） # 关系模式 # What 关系模式 关系模式 Relation Schema 是型 关系是值 关系模式是对关系的描述 元组集合的结构 属性构成 属性来自的域 属性与域之间的映象关系 # 定义 关系模式 # 关系模式与关系 关系模式： 对关系的描述 静态的、稳定的 关系： 关系模式在某一时刻的状态 or 内容 动态的、随时间不断变化的 关系模式和关系往往统称为关系 # 关系数据库 在一个给定的应用领域中，所有关系的集合构成一个关系数据库 # 关系数据库の型与值 关系数据库的型：关系数据库模式 对关系数据库的描述 关系数据库模式包括： 若干域の定义 在这些域上定义の若干关系模式 关系数据库の值： 关系模式在某一时刻对应の关系の集合 # 关系操作 # 基本关系操作 # 常用关系操作 查询：选择、投影、连接、除、并、交、差 数据更新：插入、删除、修改 查询的表达能力是其中最主要的部分 选择、投影、并、差、笛卡尔积 是 5 种基本操作 # 关系操作の特点： 集合操作方式：操作的对象和结果都是集合，一次一集合の方式 # 关系数据库语言の分类 关系代数语言：用对关系の运算来表达查询要求 代表：ISBL 关系演算语言：用为此来表达查询要求 元组关系演算语言： 谓词变元の基本对象是元组变量 代表：APLAHA,QUEL 域关系演算语言： 谓词变元の基本对象是域变量 代表：QBE 具有关系代数 and 关系演算双重特点の语言 代表：SQL # 关系的完整性 # 关系の三类完整性约束 1). 实体完整性 2). 参照完整性 关系模型必须满足の完整性约束条件 称为关系の两个不变性，应该由关系系统自动支持 3). 用户定义の完整性 应用领域需要遵循の约束条件，体现了具体领域中の语义约束 # 实体完整性 规则 2.1 实体完整性规则 (Entity Integrity) 若属性 A 是基本关系 R 的主属性，则属性 A 不能取空值 例子： SAP(SUPERVISOR, SPECIALITY, POSTGRADUATE) POSTGRADUATE: 主码 (假设研究生不会重名) 不能取空值 规则说明： 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。 现实世界中的实体是可区分的，即它们具有某种唯一性标识 关系模型中以主码作为唯一标识 主码的属性即主属性不能取空值 主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与 2) 矛盾，因此这个规则称为实体完整性 # 参照完整性 # 关系间的引用 关系模型中实体与实体间的联系都是用关系来描述的，因此肯存在着关系与关系间的引用 例子： 学生 (学号，姓名，性别，专业号，年龄) #学号是主码 专业 (专业号，专业名) #专业号是主码 学生关系引用了 专业关系的主码 “专业号” 学生关系中的 “专业号” 值 必须是确实存在的 专业的专业号，即专业 关系中有该专业的记录 例 2：学生、课程、学生与课程之间多对多联系 学生 (学号，姓名，性别，专业号，年龄) 课程 (课程号，课程名，学分) 选修 (学号，课程号，成绩) 例 3：学生实体及其内部的一对多联系 “学号” 是主码，“班长” 是外码，它引用了本关系的 “学号” “班长” 必须是确实存在的学生的 学生的学号 # 外码 H2O Ks 设 F 是基本关系 R 的一个 or 一组属性，但不是关系 R 的码 如果 F 与基本关系 S 的主码 Ks 相对应，则称 F 是基本关系 R 的外码 基本关系 R 称为参照关系 (Referencing Relation) 基本关系 S 称为被参照关系 (Referenced Relation) or 目标关系 (Target Relation) 例 1： 学生关系的 专业号 与专业关系的主码 专业号 相对应 ” 专业号 “属性是学生关系的外码 # 参照完整性规则 # 用户定义の完整性 # 关系代数 # 传统的集合运算 # 并 (Union) # 差 (Difference) # 交 (Intersection) # 笛卡尔积 (Cartesian Product) # 专门的关系运算 # 选择 # 投影 # 连接 # 除 # 关系演算 # 小结","categories":[],"tags":[]},{"title":"PCA","slug":"PCA","date":"2022-10-30T12:14:35.000Z","updated":"2022-11-08T10:05:20.655Z","comments":true,"path":"2022/10/30/PCA/","link":"","permalink":"http://rhymeet.github.io/2022/10/30/PCA/","excerpt":"","text":"# PCA_ # Step # 1. 对所有样本进行中心化： # 2. 计算样本协方差矩阵 # 3. 对协方差矩阵做特征值分解 # 4. 取最大的 m 个特征值所对应的单位特征向量 W1,W2,W3...Wn","categories":[{"name":"machine learning","slug":"machine-learning","permalink":"http://rhymeet.github.io/categories/machine-learning/"}],"tags":[]},{"title":"SQL","slug":"SQL","date":"2022-10-26T14:01:56.000Z","updated":"2022-11-03T05:41:13.680Z","comments":true,"path":"2022/10/26/SQL/","link":"","permalink":"http://rhymeet.github.io/2022/10/26/SQL/","excerpt":"","text":"# 第一章 # 1. 数据库系统概述 # 1. 四个基本概念 # 数据 Data 是数据库中存储的基本对象。 特点：数据与其语义是不可分的。 # 数据库 DB 是长期存储在计算机内、有组织的、可共享的 大量数据的集合。 基本特征：数据按一定的数据模型组织、描述和存储。 可为各种用户共享。 冗余度较小。 数据独立性较高。 易拓展。 # 数据库管理系统 DBMS 位于用户与操作系统之间的一层 数据管理软件。 是基础软件，是一个大型复杂的软件系统 用途：科学地组织和存储数据、高效地获取和维护数据 数据定义功能：提供数据定义语言 (DDL)。 定义数据库中的数据对象 数据组织、存储和管理： 分类组织、存储和管理各种数据 确定 组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方法提高存取效率 数据操纵功能： 提供数据操纵语言 (DML) 实现对数据库的基本操作 (查询、插入、删除 and 修改) 数据库的事务管理和运行管理： 数据库在建立、运行和维护时由 DBMS 统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用发生故障后的系统恢复。 数据库的建立和维护功能 (实用程序) 数据库初始数据装载转换 数据库转储 介质故障恢复 数据库 的重组织 性能监视分析 etc 其他功能： DBMS 与网络中其它软件系统的通信 两个 DBMS 系统的数据转换 异构数据库之间的互访和互操作 # 数据库系统 DBS 在计算机系统中引入数据库后的系统构成 数据库系统构成： 数据库 数据库管理系统 (及其开发工具) 应用系统 数据库管理员 # 2. 数据库系统的特点 数据结构化 数据的共享性高，冗余度低，易扩充 数据独立性高： 物理独立性 物理存储改变了，应用程序不改变 逻辑独立性 数据由 DBMS 统一管理和控制 数据独立性是由 DBMS 的二级映像功能来保证的 DBMS 提供的数据控制功能 (1). 数据的安全性保护 (2). 数据的完整性 (Integrity) 检查 (3). 并发 (Concurrency) 控制 (4). 数据库恢复 # 2. 数据模型 分两类，分属两个不同的层次 # 概念模型 (信息模型) 按 用户的观点 来对数据和信息建模，用于数据库设计。 现实世界中的客观对象抽象为概念模型 把概念模型转换为某一 DBMS 支持的数据模型 # 逻辑模型 and 物理模型 逻辑模型：主要包括网状模型、层次模型、关系模型、面向对象模型， 按计算机系统的观点对数据建模，用于 DBMS 实现 物理模型：对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。 # 1. 数据模型的组成要素 # (1) 数据结构 # (2) 数据操作 查询 更新 (包括插入、删除、修改) # (3) 完整性约束条件 一组完整性规则的集合 完整性规则：给定的数据模型中数据及其联系所具有的制约和存储规则 用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。 完整定义： (1). 反应和规定本数据模型必须遵守的基本的通用的完整性约束条件。 eg：在关系模型中，任何关系必须满足 [实体完整性] 和 [参照完整性] 两个条件。 (2). 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。 # 2. 概念模型 # 1. 信息世界中的基本概念 实体 (Entity)： 客观存在并可互相区别的事物。可以是 具体的人、事、物 or 抽象的概念 属性 (Attribute): 实体具有的某一特征。一个实体可由若干个属性来刻画。 码 (Key): 唯一标识实体的属性集。 域 (Domain): 属性的取值范围 实体型 (Entity Type): 用实体名及其属性名集合 来抽象和刻画同类实体 实体集 (Entity Set): 同一类型实体的集合 联系 (Relationship): 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系 and 实体之间的联系。 实体内部的联系通常是指组成实体的各属性之间的联系 实体之间的联系通常是指不同实体集之间的联系 # 2. 两个实体型之间的联系 # 3. 两个以上实体型之间的联系 # 4. 单个实体型内的联系 # 5. 概念模型的一种表示方法 E-R 图 # 6. 一个实例 # 3. 最常用的数据模型 # 1. 非关系模型 层次模型 (Hierarchical Model) 网状模型 (Network Model) # 2. 关系模型 (Relational Model) # 3. 面向对象模型 (Object Oriented Model) # 4. 对象关系模型 (Object Relational Model) # 4. 层次模型 是数据库系统中最早出现的 数据模型，典型代表：IBM 公司的 IMS (info Management System) 数据库管理系统；用树形结构来表示各类实体以及实体间的联系。 # 1. 层次模型的数据结构 满足 de 集合： 根节点 (有且只有一个结点 没有双亲结点) 根以外的其它结点有且只有一个双亲结点 术语：根节点，双亲结点，兄弟结点，叶结点 # 2. 多对多联系在层次模型中的表示 方法：多对多联系分解成一对多联系 分解方法： 冗余结点法 虚拟结点法 # 3. 层次模型的数据操纵与完整性约束 层次模型的数据操纵 查询 插入 删除 更新 层次模型的完整性约束条件 # 4. 层次模型的存储结构 邻接法： 按照树的前序遍历 ----&gt; 依次邻接存放，即通过物理空间的位置相邻来实现层次谁徐 链接法：(用来反映数据之间的层次关系) 子女 - 兄弟链接法： 层次序列链接法： # 5. 优缺点： 优点： 数据结构简单清晰 查询效率高，性能 优于关系模型，不低于 网状模型 提供了良好的完整性支持 缺点： 多对多联系表示不自然 对插入删除擦做限制多，引用程序的编写比较复杂 查询子女结点必须通过双亲结点 由结构严密，层次命令趋于程序化 # 5. 网状模型 # 6. 关系模型","categories":[{"name":"SQL","slug":"SQL","permalink":"http://rhymeet.github.io/categories/SQL/"}],"tags":[]},{"title":"Ch3_数据链路层","slug":"Ch3-数据链路层","date":"2022-10-16T13:51:34.000Z","updated":"2022-10-26T10:59:39.822Z","comments":true,"path":"2022/10/16/Ch3-数据链路层/","link":"","permalink":"http://rhymeet.github.io/2022/10/16/Ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"# 数据链路层 # 一、基本概念 结点：主机、路由器。 链路：网络中两个结点之间的物理通道，链路的传输介质主要有 - 双绞线、光纤 and 微波。分为 有线链路、无线链路。 数据链路：网络中两个结点之间的逻辑通道，把实现控制数据 传输协议的硬件和软件加到链路上 就构成数据链路。 桢：链路层的协议数据单元，封装网络层数据报。 数据链路层：负责通过一条链路 从一个结点向另一个物理链路直接相连的相邻结点 传送数据报。 功能概述：在物理层提供服务的基础上向 网络层提供服务，其最基本的服务是 将源自网络层来的数据可靠地传输到相邻结点的目标机网络层。 主要作用：加强物理层传输原始比特流的功能。将物理层提供的可能出错的物理连接改造成为 逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。 功能一：为网络层提供服务。 有确认无连接服务，无确认无连接服务，有确认面向连接服务。！有连接一定有确认！ 功能二：链路管理，即连接的建立、维持、释放。(用于面向连接服务) 功能三：组帧。 功能四：流量控制。 功能五：差错控制 (帧错 / 位错)。 # 二、封装成帧 &amp; 透明传输 # 1. 封装成帧 封装成帧：在一段数据的前后部分添加首部和尾部，构成一个帧。 接收端在收到物理层 上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。 首部和尾部包含许多的控制信息，重要作用 -- 帧定界 (确定帧的界限) 帧同步：接收方应当能从接收到的 二进制比特流中区分出 帧的起始和终止。","categories":[{"name":"计网","slug":"计网","permalink":"http://rhymeet.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[]},{"title":"Ch2_物理层","slug":"Ch2-物理层","date":"2022-10-16T08:18:56.000Z","updated":"2022-10-17T11:48:37.381Z","comments":true,"path":"2022/10/16/Ch2-物理层/","link":"","permalink":"http://rhymeet.github.io/2022/10/16/Ch2-%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"http://rhymeet.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[]},{"title":"Ch1_计网体系结构","slug":"Ch1-计网体系结构","date":"2022-10-16T01:48:28.000Z","updated":"2022-10-16T10:04:29.332Z","comments":true,"path":"2022/10/16/Ch1-计网体系结构/","link":"","permalink":"http://rhymeet.github.io/2022/10/16/Ch1-%E8%AE%A1%E7%BD%91%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"# 计网体系结构 # 一、概念 计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。 计算机网络是互连的、自治的计算机集合。 - 互连：通过通信链路互联互通。 - 自治：无主从关系。 # 二、功能 数据通信 资源共享 （可共享硬件、软件、数据 ） 分布式处理 （多台计算机各自承担同一工作任务的不同部分 Hadoop...） - 可靠性 - 负载均衡 # 三、组成 # 四、分类 &lt;iframe src=&quot;https://giphy.com/embed/Hm2mCUXeABqRAAOBtG&quot; width=&quot;480&quot; height=&quot;349&quot; frameBorder=&quot;0&quot; class=&quot;giphy-embed&quot; allowFullScreen&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/Hm2mCUXeABqRAAOBtG&quot;&gt; 环形网络 &lt;/a&gt;&lt;/p&gt; # 五、性能指标 速率：即数据率 or 数据传输率 or 比特率。 连接在计算机网络上的主机在数字信道上传送数据位数的速率。 带宽：表示网络的通信线路传送数据的能力，通常指单位时间内从网络中的某一点到另外一点所能通过的 “最高数据率”。单位 “比特每秒” 原指某个信号具有的频带宽度，最高频率与最低频率只差，单位是赫兹（Hz） 吞吐量单位时间内通过某个网络 (or 信道、接口) 的数据量。 时延：指数据 (报文 / 分组 / 比特流) 从网络 (or 链路) 的一端传送到另一端所需的时间。也叫延迟 or 迟延。单位 S。 时延带宽积：传播时延 x 带宽 (某段链路现在有多少比特) 往返时间 RTT：包括往返传播时延 (传播时延 * 2) + 末端处理时间 利用率：信道利用率 网络利用率","categories":[{"name":"计网","slug":"计网","permalink":"http://rhymeet.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[]},{"title":"OS(一)","slug":"os(一)","date":"2022-10-09T10:30:19.745Z","updated":"2022-11-03T09:14:37.264Z","comments":true,"path":"2022/10/09/os(一)/","link":"","permalink":"http://rhymeet.github.io/2022/10/09/os(%E4%B8%80)/","excerpt":"","text":"","categories":[{"name":"OS","slug":"OS","permalink":"http://rhymeet.github.io/categories/OS/"}],"tags":[]},{"title":"markdown","slug":"java-basic","date":"2022-09-21T14:14:48.000Z","updated":"2022-11-03T05:41:24.750Z","comments":true,"path":"2022/09/21/java-basic/","link":"","permalink":"http://rhymeet.github.io/2022/09/21/java-basic/","excerpt":"","text":"#标题一 の ## 标题二 ### 标题三 #### 标题四 这是加粗 这是斜体 这是横线 无序列表 无序列表 1. 有序序列 1 2. 有序序列 2 内嵌代码 代码块 引用 吾生也有涯，而知也无涯 &lt;!-- 有序列表 --&gt; 凯瑟琳 海瑟薇 亚瑟。皮特 &lt;!-- 无序列表 --&gt; APPLE PEACH lemon &lt;!-- 加粗 --&gt; 微信：帕克 &lt;!-- 斜体 --&gt; 微信：帕克 &lt;!-- 删除线 --&gt; 微信：帕克 # &lt;u&gt; 微信：帕克 &lt;/u&gt; 微信：帕克 # 个人博客： b 站 上标 H2O 下标 H2O &lt;!-- 高亮 --&gt; == 微信：帕克 == 未完成任务 公众号： 个人博客： 已完成任务 知乎： CSDN： 左对齐 平台 链接 公众号 jjjl 居中对齐 平台 链接 公众号 hh 就 行间公式 x1+x2=0x_1+x_2=0x1​+x2​=0 独立公式块 x2+y2=0x^2+y^2=0 x2+y2=0 链接 汲汲雨 图片","categories":[{"name":"Books","slug":"Books","permalink":"http://rhymeet.github.io/categories/Books/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://rhymeet.github.io/tags/basic/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-14T11:16:45.558Z","updated":"2022-11-09T10:43:46.987Z","comments":true,"path":"2022/09/14/hello-world/","link":"","permalink":"http://rhymeet.github.io/2022/09/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post h$ hexo new \"My New Post\"More info: Writing # Run server h$ hexo serverMore info: Server # Generate static files h$ hexo generateMore info: Generating # Deploy to remote sites h$ hexo deployMore info: Deployment H2O 210","categories":[],"tags":[]}],"categories":[{"name":"English","slug":"English","permalink":"http://rhymeet.github.io/categories/English/"},{"name":"OS","slug":"OS","permalink":"http://rhymeet.github.io/categories/OS/"},{"name":"machine learning","slug":"machine-learning","permalink":"http://rhymeet.github.io/categories/machine-learning/"},{"name":"SQL","slug":"SQL","permalink":"http://rhymeet.github.io/categories/SQL/"},{"name":"计网","slug":"计网","permalink":"http://rhymeet.github.io/categories/%E8%AE%A1%E7%BD%91/"},{"name":"Books","slug":"Books","permalink":"http://rhymeet.github.io/categories/Books/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://rhymeet.github.io/tags/basic/"}]}