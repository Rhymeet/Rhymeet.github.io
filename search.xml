<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Random</title>
      <link href="/2022/11/27/Random/"/>
      <url>/2022/11/27/Random/</url>
      
        <content type="html"><![CDATA[<p>若是能避开猛烈的欢喜，自然就不会有悲烈的来袭</p>]]></content>
      
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch4_网络层</title>
      <link href="/2022/11/27/Ch4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2022/11/27/Ch4-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CET6</title>
      <link href="/2022/11/09/CET6/"/>
      <url>/2022/11/09/CET6/</url>
      
        <content type="html"><![CDATA[<h1 id="单词"><a class="anchor" href="#单词">#</a> 单词</h1><p>bizarre     奇异的<br /> contend     竞争、坚决主张<br /> perplex     迷惑、困惑<br /> verge       边缘<br /> speciality 特产、专业、特长<br /> collective 集体的 集体<br /> kit 成套工具、用具包<br /> sly 狡猾的、诡秘的、偷偷摸摸的<br /> handful 一把、少数、费劲的<br /> living 活的、生动的<br /> erroneous 错误的<br /> deed 行为 实际 功绩 (房产) 契约证书 v. 通过行为转化<br /> hut 小屋<br /> torrent 奔流 山洪 激流的汹涌的<br /> rear 后部臀部 养育饲养建立培养<br /> mountain 山岳山脉<br /> dormitory<br />decieve 欺骗<br /> silver 银子银器<br /> waggon 四轮运货马车 敞篷货车<br /> letter 信证书 印刷 租赁人<br /> revise 修订 校订<br /> pie 喜鹊 爱说话的人 弄乱<br /> throng 群 群众 一大群 大量 拥挤的<br /> menace 威胁<br /> traverse 横越 横切<br /> recorder 首席 法官 竖笛 录音机<br /> habit 长袍 穿衣<br /> murmur 低语<br /> portuguese 葡萄牙<br /> tragedy 惨案<br /> ego 自我<br /> revolt 叛乱 反感 使・・・恶心<br /> exterior 表面的 对外的<br /> leak 泄露 漏洞<br /> assumption 傲慢 采取<br /> ditch 沟 渠道 迫降<br /> brisk 活泼的 敏锐的 凛冽的<br /> wear 磨损 耐久性<br /> exceedinly 极端地 很<br /> resignation 辞职 放弃 顺从<br /> bud 发芽<br /> chase 狩猎 追捕<br /> Oceania 大洋洲<br /> wind 卷曲 缠绕<br /> bounce 向・透露 注意 恢复<br /> conservative 守旧的<br /> cassette 匣子<br /> chorus 合唱<br /> liability 责任倾向 义务<br /> indignant 愤慨的<br /> kettle 水壶 锅 坑 穴<br /> corrode 破坏 侵蚀<br /> pretend 假托 赝品的 模拟的<br /> extraordinary 特派的 纵向的<br /> gasoline 汽油<br /> seemingly 表面上</p><p>clause 子句，条款<br /> ambulance 救护车 野战 医院<br /> tribe 部落 宗族<br /> sensation 感觉 知觉 轰动<br /> canal 建河 疏导<br /> undertaking 任务 事业 企业 保证 许诺<br /> leap 跳跃 猛冲<br /> sore 疮痛处 痛心的 恼火的<br /> oval 卵形的<br /> locality 位置<br /> disposal 丢掉 处理 销毁 碾碎器<br /> interval 间隔 休息间距<br /> retort 反击 反驳<br /> interpret 解释 口译 演出<br /> apprehension 理解 忧惧 逮捕<br /> opaque 不透明的 不传导的<br /> impart 给予 传递 告诉<br /> rusty  生锈的<br /> tremendous 极大的 巨大的 惊人的<br /> sympathetic 同情的共鸣的 交感神经<br /> exceed 超出 领先<br /> foreigner<br />commend 称赞 表扬<br /> vain 虚荣的<br /> manipulate 操作 控制 手持<br /> millimetre 毫米<br /> ward 病房<br /> identical<br />soap 肥皂 阿谀奉承<br /> Atlantic 大西洋<br /> dismay 惊慌 沮丧 灰心<br /> thorn 刺 荆棘<br /> summit 顶点 极度 最高点<br /> representative 典型的<br /> compulsory 强迫的 义务的<br /> electronics 电子学<br /> announcer<br />noun 名词<br /> ascertain 查明 弄清<br /> envelope 封套 皮壳<br /> preliminary<br />hoist 生气 扯起来<br /> flaw 瑕疵 裂缝<br /> sociology 社会学<br /> narrative 叙述 故事<br /> tariff 关税 价格表<br /> refine 精炼 提纯 净化<br /> valve 阀门 电子管<br /> transplant 移植 种植<br /><strong> divine</strong> 神的 敬神的<br /> evolution 进化 发展<br /> bribe 贿赂<br /> clutch 抓住 掌握<br /> sufficiently<br />dentist<br />costume 装束<br /> alter 改变<br /> ounce gen 司 英两<br /> metallic 金属的 金属粒子<br /> efficient 有胜任的<br /><strong> veil</strong> 面纱 面罩 修女<br /> aggressive 侵略的 好斗的 攻击性的<br /> motor 机动的<br /> ball 球状舞会<br /> elite 精英 中坚分子<br /> simplicity 简朴<br /> toe 脚趾<br /><strong> dilute</strong> 冲淡 稀释<br /> bracket 支架 括弧 托架<br /> cement 水泥胶 结合剂 补牙物 基石 v 维护保养<br /> compile 搜集<br /> tease 戏弄 强求<br /> shrug 怂 耸肩<br /> enroll 登记 参军<br /> comb 梳子 鸡冠 蜂巢<br /> exceptation 预期<br /> crime 羞耻 犯罪<br /> erosion 糜烂<br /> commerce 社交 贸易<br /> plaster 灰泥 石膏药<br /> feeble 虚弱的 微弱的<br /> sake 理由 利益 好处<br /> materialism 唯物主义 实例主义<br /> upside-down 颠倒的 乱七八糟<br /> gang 一帮 一伙<br /> sensible 明智的 可察觉的 实用的<br /> club 夜总会<br /> suck 吮吸<br /> mill 磨坊 制造厂<br /> preferable 更合意的<br /> agent 工人 药剂<br /> adverse 相反的 逆的 敌对的<br /> initial<br />scope 范围 能力 眼力 仔细研究<br /> democracy 民主 民主国家<br /> humorous<br />invest 包围<br /> preposition 前置词介词<br /> recur 再发生 重现<br /> expertise 专家的意见 专门技术<br /> coil 线圈绕 盘绕<br /> commodity 日用品 商品 物品<br /> federation 联邦 联盟<br /> weight 使负重 、倾斜<br /> hysterical 歇斯底里的 异常兴奋的<br /> timid 胆怯的      羞怯的<br /> breakdown 崩溃<br /> suspicious 猜疑的<br /> warfare<br />clearance 清除 间隙<br /> pillar 柱子  栋梁<br /> velocity  速率 迅速<br /> authorize<br />plant 设备 设立 工厂<br /> deer 鹿<br /> fourth<br />superb 壮丽的 超等的<br /> coherent 粘着的 紧凑的<br /> reconcile 使和好 调停<br /> discern 辨出<br /> communist 共产主义的<br /> curt 简略的 生硬的 简短的<br /> succession 继承<br /> investigation 研究 调查<br /> smuggle 私运 走私<br /> imagine 认为 猜测<br /> meridiem 正午<br /> electricity<br />hedge 篱笆 障碍物 限制 拐弯抹角<br />保护自己不受财产损失<br /> inspection 视察<br /> forehead<br />tragic<br />physician 内科医生<br /> difference 分歧<br /> post 竿 邮件<br /> moderate 温和的 适度的 稳健的<br /> anticipate 预期<br /> interst 利益 嗜好 股份 利息<br /> pint 品脱<br /> resemblance 相似 相似性<br /> corresponding 符合的 一致的 相当的<br /> overlook 看漏 忽视<br /> horrible 极可厌的<br /> revelation 揭露 泄露 启示 展示<br /> humble 谦逊的 粗鄙的<br /> bull 斗牛犬 宗教 猛冲<br /> devise 设计 遗赠 (的财产)<br /> snap 猛咬 突然折断<br /> commute 交换 兑换 经常来往<br /> lorry 运货 汽车卡车<br /> portion  一部分 命运 分担的责任<br /> correspondent 通讯记者 与。相应<br /> horrible 极可恶的</p><p>revelation 揭露 泄漏 启示<br /> practise 实践<br /> indirect 迂回的 欺骗的<br /> orient 亚洲 远东 东方<br /> corrupt 贿赂 腐败的<br /> mock 嘲弄 挖苦<br /> diverse<br />misfortune 灾祸 灾难<br /> deprive 夺去 使失去<br /> dew 露水<br /> hydrogen 氢<br /> conspicuous 显眼的 出众的<br /> bank 堆积<br /> blow 殴打 吹响<br /> practicable 能实行的 适用的<br /> northern 北部的<br /> gloomy 黑暗的 令人沮丧的<br /> cater 迎合 投合<br /> vacuum 真空空间吸尘器<br /> misunderstand 误会 曲解<br /> instance 诉讼 例子 程序<br /> conform 使遵守 一致<br /> shrewd 精明的敏锐的<br /> storage 贮藏 存储 保管 仓库<br /> philosopher 哲学家<br /> inhabit 栖息于<br /> dwell 居住 凝思 细想<br /> hamper 妨碍 阻碍 牵制<br /> longitude 经线<br /> steamer 汽船 蒸笼<br /> wreath 花环 花圈 花冠<br /> facet 方面 刻面<br /> consequent 必然的 作为结果的<br /> nightmare 噩梦<br /> oath 誓言 宣誓<br /> breeze 微风 轻而易举的事<br /> dish 菜肴 凹形 挖空 闲谈<br /> prolong 拖延<br /> reckless 鲁莽的<br /> disclose 揭露<br /> interpreter 程序<br /> allowance 津贴<br /> beef 抱怨诉苦<br /> headquarters 司令 指挥 总部<br /> resonance 共鸣 共振<br /> widow 寡妇 遗孀<br /> ceramic 陶器的<br /> transcend 超过 胜过<br /> habitual 习惯的<br /> skirt 边缘郊区<br /> gulf 海湾<br /> quart 夸脱 (=2 品脱)<br /> unusually 显著的<br /> drown 淹死<br /> statistics 统计数字<br /> sentence 判决 刑罚 命题 使遭受<br /> lend 贷款 增添 给予<br /> adverb 副词<br /> encounter 遭遇 偶然 碰到<br /> converge 聚合 集中于一点</p><p>bolt 螺 栓 钉 闪电 狼吞虎咽<br /> B.C. 公元前<br /> oral 口试<br /> whistle  啸啸 汽笛<br /> simple 无辜的 纯粹的 n. 平民 精神病人 草药<br /> lest 唯恐 以免<br /> mutual 相同的 共同的<br /> compensate 补偿 赔偿<br /> tow 牵引<br /> waterproof 不透水的 防水的 雨衣<br /> photograph 照相 照片<br /> mortgage 抵押</p><p>disposition 性情 处置 处理 布置<br /> elevate 提高 抬高<br /> concentrate  聚集 浓缩 精选</p><p><strong>trifle</strong> 小事 琐事 浪费 玩忽<br /> tell 吩咐 辨别 告诉<br /> dragon 凶暴的人<br /> quartz 石英<br /> security 保证 抵押 债券证券<br /> competitive 竞赛的 比赛的<br /> eve 前夜 前夕<br /> thereafter 此后以后<br /> bulletin 告示 公告</p><p>student 研究生 学者<br /> reflexion 反射 映像 折射 考虑 = reflection<br />July 七月<br /> meal 膳食 谷物进餐<br /> adjoin 贴近 吡连 靠近<br /> progress  前进 进步<br /> slippery 狡猾的 不可靠的<br /> recreation 消遣 娱乐活动<br /> sue 控告 请愿<br /> deem 认为 想<br /> hostage 人质 抵押品<br /> crush 碾碎 镇压 关键时刻 果汁<br /> repay 偿还 报答<br /> relativity 相关性<br /> buzz 嗡嗡<br /> recession 衰退<br /> proportional 比例的 相称的</p><p>startle 吃惊<br /> sausage 腊肠<br /> boycott 联合抵制<br /> presumably  推测起来 大概<br /> copper 铜币 镀铜 一种蝴蝶<br /> spectacular 惊人的 展览物<br /> definitely 确切的<br /> condemn 谴责<br /> rouse 唤醒<br /> hasten 催促 急忙<br /> symposium  专题研讨会 讨论会<br /> drive 驾驶驱入<br /> journalist  记者<br /> republic 共和国 共和政体<br /> diameter 直径<br /> outlook 观点 前景 景色<br /> shipment 货物<br /> intricate 复杂的 纠缠的<br /> suppress 镇压 隐瞒<br /> servant 雇工<br /> deficiency 缺乏<br /> prayer 祷告<br /> immigrant<br />manufacture 制造加工<br /> illusion 幻想 错觉<br /> onto 到... 上<br /> division 分配 除法<br /> continuous 连续不断的<br /> versatile 多方面的<br /> bankrupt 破产<br /> dignity<br />legislation 立法 法规<br /> prototype 原型<br /> flank 肋 侧面的<br /> instantaneous 瞬间的 即刻的<br /> tomorrow<br />tug 猛拖<br /> repetition 重复 反复<br /> exhaust 耗尽 排气装置<br /> illegal 非法移民<br /> stiffen 使僵硬 变粘稠<br /> criticism 批判 评论<br /> shed 脱落 流出 小棚<br /> descend 下降<br /> vegetation 植物 草木<br /> reproach 责备 耻辱<br /> volume 卷册 容积 体积 音量<br /> electrician 电工技师<br /> handicap 妨碍 使不利<br /> stumble 绊倒 踌躇<br /> notable 著名的<br /> warrant 许可证 正当理由 委任状<br /> obstacle 障碍物</p><h1 id="金山词霸"><a class="anchor" href="#金山词霸">#</a> 金山词霸</h1><h1 id="day1"><a class="anchor" href="#day1">#</a> day1</h1><ol><li>expire 满期  到期 断气 散发<br /> embody 体现 包含</li></ol><p>periodical 期刊</p><p>overlap 重叠 覆盖物<br /> deligate 代表<br /> christian 基督教的<br /> dwarf 矮子</p><p>ferrous 铁的<br /> treasurer 司库 财务主管</p><p>wield 挥 行使<br /> Christ  n. 救世主<br /> christian 基督教的<br /> ironical 讽刺的<br /> everlasting 永久的<br /> breakdown 细目列表</p><h1 id="2-excise-切除"><a class="anchor" href="#2-excise-切除">#</a> 2. excise 切除</h1><p>subsequent 随后的 后来的<br /><strong> incredible 惊人的</strong><br /> charter 宪章 章程 包租 发给...<br />Moslem 穆斯林的<br /> duke 公爵</p><p>pose 提出 造成<br /><strong> hamper 妨碍 牵制</strong><br /> analytic<br /><strong>vigorous 剧烈的</strong> 活跃的 精神旺盛的</p><ul><li>He is none the less <strong>vigorous</strong> for his years.<br /> 他虽年老而依然健壮.</li></ul><p>resemblance 相似<br /> escort 陪同 护送<br /><strong> narration 叙事 故事</strong></p><h1 id="3-extraction-抽出-血统-家世"><a class="anchor" href="#3-extraction-抽出-血统-家世">#</a> 3. extraction 抽出 血统 家世</h1><p><strong>counsel 律师 忠告</strong><br /> propaganda 宣传<br /> avail 益处<br /> pneumatic 充气的<br /><strong> furious 狂怒的 激烈的</strong></p><p><strong>taper 逐渐变细 ，减少</strong><br /> acquaint 使结识 了解<br /> datum 资料 数据<br /> counsel 建议 忠告 律师<br /> attorney 辩护律师</p><p>propaganda 宣传<br /> pneumatic 充气的 气动的</p><h1 id="4-referee-裁判"><a class="anchor" href="#4-referee-裁判">#</a> 4. referee 裁判</h1><p>locality 位置<br /> sift 筛子<br /> brand 在。上烙印 加污名于<br /> installment 分期付款<br /> instrumental 有帮助的 乐器的<br /> descent 出身 下降 斜坡<br /> subsequently 其次 接着<br /> adjacent 毗邻的<br /> commence 获得学位 着手<br /> balcony 阳台 楼厅<br /> thereof 在其中 它的<br /> editorial 社论的 编辑的<br /> mustard 芥末<br /> sandwich 夹裹 把... 夹入</p><h1 id="5-goodness-善良-美德"><a class="anchor" href="#5-goodness-善良-美德">#</a> 5. goodness 善良 美德</h1><p>plump 丰满的 胖乎乎的<br /> contradict 反驳<br /> xerox 复印 影印<br /> cross 生气的 愤怒的<br /> herald 预告 宣布<br /> detach 分开 拆卸 使脱离<br /> bazaar 集市 义卖<br /> pantry 食品柜 餐具室<br /> integrity 诚实 正直 完整<br /> decorative<br />documentary 文件的<br /> survival 遗物 幸存<br /> successor 继任者</p><h1 id="6-tread-踩-踏-步行"><a class="anchor" href="#6-tread-踩-踏-步行">#</a> 6. tread 踩 踏 步行</h1><p>disorder 失调<br /><strong> wharf 码头 停泊所</strong><br /> confirmation 证实<br /> streamline 精简<br /> practicable 切实可行的<br /> pilgrim 香客 朝圣者<br /> equation 平衡 综合体<br /> radical 基本的  彻底的 激进的<br /> revenue 收入 收益 税收<br /> offspring</p><h1 id="7-superstition-迷信-迷信观念"><a class="anchor" href="#7-superstition-迷信-迷信观念">#</a> 7. superstition 迷信 迷信观念</h1><p>infinite 无限的 无穷的 极度的<br /> damn 一点点 丝毫 诅咒 谴责<br /> hail 冰雹 一阵<br /> rapture 狂喜<br /> periodic 周期的<br /> cloak 披风 斗篷 借口 掩饰<br /> rectify 纠正 修正<br /> senator 参议员<br /> censeless 无意义的 失去知觉的<br /> magnitude 巨大 重要性 震级<br /> deprive 剥夺</p><h1 id="8-respectable-可敬的-可观的-体面的"><a class="anchor" href="#8-respectable-可敬的-可观的-体面的">#</a> 8. respectable 可敬的 可观的 体面的</h1><p>viscous 粘的<br /> blunder 疏忽<br /> continental 欧洲大陆的 大陆的<br /><strong> coordinate 使协调 调和</strong><br /> assassinate 暗杀 刺伤<br /> grunt 呼呼声<br /> hurricane<br />shovel 铲</p><h1 id="9-ruby-红宝石"><a class="anchor" href="#9-ruby-红宝石">#</a> 9. ruby 红宝石</h1><p>contrast<br />deform  使变形 损毁外形<br /><strong> integrate 使融入 使结合</strong><br /> psychology 心理学 心里<br /> haughty 傲慢的 目中无人的<br /> blaze 燃烧<br /> inevitably 不可避免的<br /> inadequate 不充足的 不够格的<br /> inaccurate 不精确的<br /> specimen 抽样 样本<br /> pal 朋友<br /> incorporate 使并入 包含<br /> haughty 傲慢的 目中无人的</p><h1 id="10-strife-冲突"><a class="anchor" href="#10-strife-冲突">#</a> 10. strife 冲突</h1><p>consistent<br />friction 矛盾 不和<br /> slide 贬值 滑动<br /> gangster 匪徒<br /> inaugurate 开创 为举行</p><p><strong>kinetic 运动的</strong><br /> rooster 公鸡<br /> patriot 爱国者<br /> absorption 吸收 合并<br /> inaugurate 开创<br /> friction 矛盾 摩擦力</p><h1 id="11-dictator-独裁者"><a class="anchor" href="#11-dictator-独裁者">#</a> 11. <strong>dictator 独裁者</strong></h1><p>nourishment 滋养品 营养<br /><strong> interior 内部的 内心的</strong><br /> inflation 通货膨胀<br /> strip 狭长区域<br /> antique 古董<br /> intake 摄取量<br /> magician 巫师<br /> tact 机敏 圆滑 得体<br /> inspiration 灵感 妙计<br /> baffle 挡板 困惑<br /> interior 内部的 内心的</p><h1 id="12-incline-斜坡-斜面"><a class="anchor" href="#12-incline-斜坡-斜面">#</a> 12. incline 斜坡 斜面</h1><p><strong>ambient 周围的 四周的</strong><br /><strong> inertia 惯性 惰性 迟钝</strong><br /> tyrant 暴君 专制君主 专横的人<br /><strong> modification 缓和 修改 修饰</strong><br /> competitive 竞争的<br /><strong> antenna 天线 触角</strong><br /><strong> agitation 鼓动 搅动 焦虑 烦恼</strong><br /> twilight 黄昏 暮光<br /> meditate 沉思 冥想 仔细考虑<br /> ascend 攀登 上升<br /> graze 擦伤 放牧<br /> clown 小丑</p><h1 id="13-drainage-排水"><a class="anchor" href="#13-drainage-排水">#</a> 13. drainage 排水</h1><p>luxurious 奢侈的 豪华的惬意的<br /> implore 乞求 恳求 哀求<br /> conviction 确信 定罪 判罪<br /> hinge 合页 铰链<br /> dome 圆屋顶 半球形物<br /> sensitivity 敏感性 灵敏性<br /> liner 邮轮 客轮 衬里 衬垫</p><p>veto 否决<br /> bull 公牛 雄兽 买空的证券投机商<br /> bribe 行贿<br /> response 回复 回答<br /> commission 授权 委托 佣金<br /> smart 刺痛 剧透 难受<br /> negligible 微不足道的 可忽略不计的</p><h1 id="14-axle-轮轴-车轴"><a class="anchor" href="#14-axle-轮轴-车轴">#</a> 14. axle 轮轴 车轴</h1><p>whilst 同时 时时<br /> metallic<br /><strong>persecute 迫害 残害 骚扰</strong><br /> fro 向后 向那边<br /> zinc 镀锌<br /> coincide 巧合 同时发生<br /> unanimous 一致同意的 无异议的<br /> theorem 定理<br /><strong> persecute 迫害 残害 骚扰</strong><br /> pamphlet 小册子<br /> overthrow 推翻 瓦解<br /> multiplication<br />decisive 决定性的 果断的<br /> awkward 使人尴尬的 难携带的 笨拙的<br /> quantitative 大小的数量的</p><h1 id="15-resultant-作为结果的"><a class="anchor" href="#15-resultant-作为结果的">#</a> 15. resultant 作为结果的</h1><p>velocity 速率<br /> disperse 分散 驱散<br /> inspector 巡警 督察长<br /> composite 合成物<br /> realistic 现实的<br /><strong> resent 怨恨</strong><br /> unique<br />islam 伊斯兰教<br /> woodpecker 啄木鸟<br /><strong> whitewash 粉饰 石灰水粉刷</strong><br /> reside 居住 属于<br /><strong> perstige 威望 声望</strong></p><h1 id="16-empirical-经验主义的"><a class="anchor" href="#16-empirical-经验主义的">#</a> 16. <strong>empirical 经验主义的</strong></h1><p><strong>partinent 恰当的 中肯的</strong><br /> induce 劝诱 劝说<br /> flaw 瑕疵 谬误<br /> inorganic 无生物的 无机的<br /> specificaion 详述 规格 说明书<br /> collide 碰撞<br /> filement 细丝 细线 细状物<br /> colonist 移民</p><h1 id="17-inclination-倾向-爱好"><a class="anchor" href="#17-inclination-倾向-爱好">#</a> 17. inclination 倾向 爱好</h1><p>cereal 谷物 麦片<br /> personaliy 个性 性格<br /> incidentally 附带地 顺便提及<br /> estate 地区 遗产 住宅区<br /> proverb 谚语 格言<br /> superficial 表面的 肤浅的<br /> fossil 化石的<br /> sequence 序列<br /> decompose 使腐烂 分解</p><h1 id="18-tuberculosis-结核病-肺结核"><a class="anchor" href="#18-tuberculosis-结核病-肺结核">#</a> 18. tuberculosis 结核病 肺结核</h1><p>foresee<br />tile 瓦片 瓷砖<br /> mistress 情妇女主人<br /> villa 别墅<br /> historian<br />popularity 声望 流行<br /> maple<br />cleanliness<br />span 墩距 间隔<br /> blond 白肤金发碧眼的人<br /> scope 眼界 施展余地 机会<br /> seige 包围 围攻<br /> bridegroom 新郎<br /> merchandise 买卖 销售</p><p>optical 光的<br /> burglar 夜盗 窃贼<br /> preset 预先设置<br /> propulsion 推进</p><h1 id="19-passport-护照"><a class="anchor" href="#19-passport-护照">#</a> 19. passport 护照</h1><p>undertake 承诺 从事<br /> ridicule 嘲弄 奚落<br /> theatre 剧院 演戏</p><p>cosmic 宇宙的<br /> gnaw 折磨<br /> jug 壶<br /> greed<br />torque 扭转<br /> bypass 路过</p><h1 id="20-applaud"><a class="anchor" href="#20-applaud">#</a> 20. applaud</h1><p>equator 赤道<br /> radiator 暖气片 散热器 冷却器<br /><strong> perpendicular 垂直 (线)</strong><br />deficient<br /><strong>scrap 废弃 取消</strong><br /> consul 领事<br /> rear 饲养 领养<br /><strong> overhear 偶然听到 偷听</strong><br /><strong> eloquence 雄辩 口才</strong><br /><strong> plateau 高原 平稳时期</strong><br /><strong> operation 企业</strong><br /><strong> stride 大步 步态 进展</strong><br /> finance<br />makeup 体格<br /> unreasonable<br />eclipse 日食月食 黯然失色</p><h1 id="21-symphony-交响乐"><a class="anchor" href="#21-symphony-交响乐">#</a> 21. symphony 交响乐</h1><p>alteration 更改<br /> vaccinate 给。接种疫苗<br /> earnings 工资<br /> wardrobe 衣柜 衣橱 行头</p><ul><li>feminine 女性的 阴性的</li><li>masculine 男性的 阳刚的<br /> supplement 增刊<br /> offset 抵消 补偿<br /> substantial 物质的 坚固的 大量的</li></ul><p>mend 修改 康复<br /> second 临时调任<br /> productivity 生产率<br /> shady 可疑的 背阴的 不正当的<br /> notion 观点<br /> endeavor 尝试 试图<br /> compatible 兼容的</p><h1 id="22-siren-汽笛-警报器-妖妇"><a class="anchor" href="#22-siren-汽笛-警报器-妖妇">#</a> 22. <strong>siren 汽笛 警报器 妖妇</strong></h1><p><strong>requisite 必需品</strong><br /> consolidate 合并 联合<br /> aviation 航空 飞机制造业<br /> horn 角状物 喇叭 角质<br /> coward 胆小鬼 懦夫<br /> destiny 命运<br /> pedlar 流动小贩<br /> supersonic 超音速的<br /> allied 联合的 同盟的<br /> insignificant<br />ponder<br />certainty</p><h1 id="23-panther-豹-黑豹-美洲豹"><a class="anchor" href="#23-panther-豹-黑豹-美洲豹">#</a> 23. panther 豹 黑豹 美洲豹</h1><p>ward 病房 被监护人<br /> vicious 残暴的 恶意的<br /> reactor 反应堆<br /> inferior 差的<br /> Mars 火星 战神<br /> metropolitan 大主教<br /> frustrate 挫败 沮丧<br /> fabrication 制造 构造物 捏造<br /><strong> lodging 寄宿 租住的房间</strong><br /><strong> tyranny 暴政 专横</strong><br /> saturation 饱和 浸透<br /> catholic 天主教徒<br /> productive<br />ignorance<br />immigrate</p><h1 id="24-bourgeois-资产阶级的"><a class="anchor" href="#24-bourgeois-资产阶级的">#</a> 24. <strong>bourgeois 资产阶级的</strong></h1><p>manifest 明显的 显而易见的<br /> patriotic 爱国的<br /> obedient 服从的 顺从的 温驯的<br /> expedition 探险 远足<br /> overestimate 过高估计、评价<br /> establish 查实<br /> patron 代言人<br /> intonation 语调 声调<br /> characterize 描述<br /> perfection 完美<br /> leakage 漏出<br /> opaque 不透明是<br /> hymn 圣歌 歌颂<br /> moor 使停泊<br /> consumption</p><h1 id="25-ultrasonic-超声波"><a class="anchor" href="#25-ultrasonic-超声波">#</a> 25. ultrasonic 超声波</h1><p>fluctuation  波动 起伏 涨落<br /> symmetrical 对称的 匀称的<br /> mock 嘲弄<br /> flap 拍打<br /> massacre 大屠杀<br /> signify 意味着<br /> handout 施舍物 救济品 讲义<br /> terminology 术语 专用术语<br /><strong> occurrence 事件 发生</strong><br /><strong> cruise 航船 游览</strong><br /> untie 解开 松开<br /> compliment 赞美<br /> boiler<br />misfortune<br />cruise 乘船游览、航游</p><h1 id="26-ranch-大农厂"><a class="anchor" href="#26-ranch-大农厂">#</a> 26. ranch 大农厂</h1><p>rational 理性的 理智的<br /> peripheral 周围的 次要的<br /> predominant 占优势的<br /> executive 总经理 主管 行政部门<br /> deposition 罢免 沉淀 书面证词<br /> compact 把.. 压实<br /><strong> decree 法令 判决</strong><br /> hover 犹豫不决 徘徊<br /><strong> flux 流体 波动</strong><br /><strong> bewilder 使困惑 使糊涂 不知所措</strong><br /><strong> prevalent 流行的 盛行的</strong><br /> perplex 迷惑<br /> seaport 海港 港口城市<br /> politics<br />diagnose<br />photography<br />recommendation</p><h1 id="27-errand-差事"><a class="anchor" href="#27-errand-差事">#</a> 27. errand 差事</h1><p>tensile 张力的 能伸长的<br /> petition 请愿<br /> tape 录制 粘贴<br /> enlighten 启发<br /> liability 责任 债务 累赘<br /> currency 货币<br /> ware 商品 货物 陶器<br /> puff 吹<br /> equilibrium 平衡 均衡 平静<br /> utensil 器皿 用具<br /> sensible 明智的 理智的<br /> baron 男爵 大亨 巨头<br /> royalty 王室 版费 使用费<br /> torpedo 用鱼雷袭击 故意破坏<br /> crisis</p><h1 id="28-ventilate-使通风-发表看法"><a class="anchor" href="#28-ventilate-使通风-发表看法">#</a> 28. ventilate 使通风 发表 (看法)</h1><h2 id="wrath-狂怒"><a class="anchor" href="#wrath-狂怒">#</a> wrath 狂怒</h2><p>stern 严厉的<br /> stem 茎<br /> essense 本质 精华 精油<br /> prey 猎物 伤害的对象<br /> aerial 空气中的 航空的<br /> mortgage 抵押<br /> individual 单独的<br /> grind 磨碎 用力挤压<br /> barge 驳船 游艇<br /> supervise 监督<br /> locomotive 机车 火车头<br /> vowel 元音<br /> squeeze<br />version<br />notify<br />thereafter<br />optimism</p><h1 id="29fortress-ˈfɔtris堡垒-要塞"><a class="anchor" href="#29fortress-ˈfɔtris堡垒-要塞">#</a> 29.fortress  [ˈfɔ:tris] 堡垒 要塞</h1><p>initiate 开始 创始 接纳<br /> deputy [ˈdepjuti] 副的 代理人<br /> diesel  [ˈdi:zəl] 柴油 柴油车<br /> exceptional 优越的<br /> versatile 多才多艺的 多功能的<br /> mount 山峰 坐骑<br /> indefinite 无限期的<br /> cradle 摇篮 发源地<br /><strong> peril</strong> [ˈperil]  n. 重大危险；（某活动或行为的）危险，...<br /><strong>bid 努力 投标</strong><br /><strong> sheriff 郡长 县治安官</strong><br /> missionary 传教士<br /> nursery 苗圃 托儿所<br /> mobilize 动员起来<br /> observe<br />Jesus<br />deem<br />composition</p><h1 id="30-perception-感觉-洞察力-理解"><a class="anchor" href="#30-perception-感觉-洞察力-理解">#</a> 30. perception 感觉 洞察力 理解</h1><p>hazard 危险<br /> molecular [məˈlekjələ] 分子的<br /> patent 专利<br /> goddess [ˈgɔdɪs]  n. 女神；被崇拜的女人<br /> grassy [ˈgræsi:]  adj. 长满草的；覆盖着草的<br /> hospitality  [ˌhɔspiˈtæliti]  n. 殷勤好客；热情友好；款待<br /> outlet [ˈautlet]  n. 出口；排放管；（情感的）发泄途径；.<br />dove [dʌv]  n. 鸽子；（政界的）鸽派人士<br /> yolk 蛋黄<br /> measurement</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>relate_words</title>
      <link href="/2022/11/09/relate-words/"/>
      <url>/2022/11/09/relate-words/</url>
      
        <content type="html"><![CDATA[<h1 id="semaphore-ˈseməˌfôr"><a class="anchor" href="#semaphore-ˈseməˌfôr">#</a> semaphore /ˈseməˌfôr/</h1><p>名词：信号，旗语，臂板信号，信号机<br /> binary semaphore 二进制信号量</p><h1 id="simultaneously-同时地"><a class="anchor" href="#simultaneously-同时地">#</a> simultaneously 同时地</h1><h1 id="exclusive-独有的-专用的-排外的-排斥的"><a class="anchor" href="#exclusive-独有的-专用的-排外的-排斥的">#</a> exclusive   独有的、专用的、排外的、排斥的</h1><h1 id="synchronization-同步"><a class="anchor" href="#synchronization-同步">#</a> synchronization 同步</h1><h1 id="mutel-exclusion-within-the-monitor"><a class="anchor" href="#mutel-exclusion-within-the-monitor">#</a> mutel exclusion within the monitor</h1><p>监视器内的互斥排除</p><h1 id="monitor-管程"><a class="anchor" href="#monitor-管程">#</a> monitor 管程</h1>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OS(三)内存管理</title>
      <link href="/2022/11/09/OS-%E4%B8%89-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/11/09/OS-%E4%B8%89-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理の概念"><a class="anchor" href="#内存管理の概念">#</a> 内存管理の概念</h1><h2 id="内存空间の分配与回收"><a class="anchor" href="#内存空间の分配与回收">#</a> 内存空间の分配与回收</h2><blockquote><p>操作系统负责<strong>内存空间的分配与回收</strong></p></blockquote><h2 id="内存空间の扩充"><a class="anchor" href="#内存空间の扩充">#</a> 内存空间の扩充</h2><blockquote><p>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></p></blockquote><h2 id="地址转换"><a class="anchor" href="#地址转换">#</a> 地址转换</h2><blockquote><p>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址</strong>与<strong>物理地址</strong>的转换</p></blockquote><p>程序员只需关注指令、数据的逻辑地址。<br />而逻辑地址到物理地址的转换 (此过程称为<strong>地址重定位</strong>) 应该由 OS 负责</p><p>三种装入方式</p><ol><li>绝对装入：编译时产生绝对地址<br />编译器负责地址转换<br /> (单道程序阶段，此时还没有产生操作系统)</li><li>可重定位装入：装入时将逻辑地址转换为物理地<br />装入程序负责地址转换<br /> (用于早期的多道批处理系统)</li><li>动态运行时装入：运行时将逻辑地址转换为物理地址，需设置重定位寄存器<br />运行时才负责地址转换<br /> (现代操作系统)</li></ol><h2 id="内存保护"><a class="anchor" href="#内存保护">#</a> 内存保护</h2><blockquote><p>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰</p></blockquote><ul><li>方法 1：在 CPU 中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU 检查是否越界。<br /><a href="https://imgse.com/i/zAzy38"><img data-src="https://s1.ax1x.com/2022/11/15/zAzy38.jpg" alt="zAzy38.jpg" /></a></li><li>方法 2：采用<strong>重定位寄存器</strong> (又称<strong>基址寄存器</strong>) 和<strong>界地址寄存器</strong> (又称<strong>限长寄存器</strong>) 进行越界检查。<br />重定位寄存器中存放的是进程的 起始物理地址，<br />界地址寄存器中存放的是进程的 最大逻辑地址。<br /><a href="https://imgse.com/i/zAz6gS"><img data-src="https://s1.ax1x.com/2022/11/15/zAz6gS.jpg" alt="zAz6gS.jpg" /></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kmeans</title>
      <link href="/2022/11/07/Kmeans/"/>
      <url>/2022/11/07/Kmeans/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4_mul_linerRegression</title>
      <link href="/2022/11/07/4-mul-linerRegression/"/>
      <url>/2022/11/07/4-mul-linerRegression/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS(二)进程与线程</title>
      <link href="/2022/11/03/OS-%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/11/03/OS-%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程の概念-组成-特征"><a class="anchor" href="#进程の概念-组成-特征">#</a> 进程の概念、组成、特征</h1><p>概念：是动态的 是程序的一次执行过程<br />概念：是<strong>进程实体</strong>的运行过程，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位</p><h2 id="进程の组成-pcb"><a class="anchor" href="#进程の组成-pcb">#</a> 进程の组成 - PCB</h2><p>进程被创建时，OS 为其分配の Process ID<br />OS 要记录 PID、进程所属用户 ID（UID）</p><p><strong>PCB 是进程存在の唯一标志</strong> process control block<br /><a href="https://imgse.com/i/z3CKW6"><img data-src="https://s1.ax1x.com/2022/11/22/z3CKW6.jpg" alt="z3CKW6.jpg" /></a></p><p><a href="https://imgse.com/i/z3CYTA"><img data-src="https://s1.ax1x.com/2022/11/22/z3CYTA.jpg" alt="z3CYTA.jpg" /></a></p><p>PCB 、程序代码、数据段 组成了<strong>进程实体 (进程映像)</strong><br /> PCB 是给 OS 用的<br />程序代码、数据段是给进程用的</p><p>一个<strong>进程实体 (进程映像)<strong> 由</strong> PCB、程序段、数据段</strong>组成。<br />进程是动态的，** 进程实体 (进程映像)** 是静态的。</p><h2 id="进程d特征"><a class="anchor" href="#进程d特征">#</a> 进程 d 特征</h2><p>动态性是 most basic<br /><a href="https://imgse.com/i/z3PfUA"><img data-src="https://s1.ax1x.com/2022/11/22/z3PfUA.jpg" alt="z3PfUA.jpg" /></a></p><h1 id="进程の状态与转换"><a class="anchor" href="#进程の状态与转换">#</a> 进程の状态与转换</h1><p><a href="https://imgse.com/i/xqnoIe"><img data-src="https://s1.ax1x.com/2022/11/03/xqnoIe.png" alt="xqnoIe.png" /></a></p><h2 id="状态"><a class="anchor" href="#状态">#</a> 状态</h2><h3 id="创建态-就绪态"><a class="anchor" href="#创建态-就绪态">#</a> 创建态、就绪态</h3><blockquote><p>进程正在被创建时，它的状态是 “<strong>创建态</strong>”，在这个阶段操作系统会为进程 分配资源，初始化 PCB</p></blockquote><blockquote><p>当进程创建完成后，便进入 “<strong>就绪态</strong>”，处于就绪态の进程已经具备运行条件，但由于没有空闲の CPU，就暂时不能运行</p></blockquote><h3 id="运行态"><a class="anchor" href="#运行态">#</a> 运行态</h3><blockquote><p>如果一个进程此时在 CPU 上运行，那么这个进程称处于 “<strong>运行态</strong>”<br />CPU 会执行该进程对应の程序 (执行指令序列)<br /><a href="https://imgse.com/i/xqQHTf"><img data-src="https://s1.ax1x.com/2022/11/03/xqQHTf.png" alt="xqQHTf.png" /></a></p></blockquote><h3 id="阻塞态"><a class="anchor" href="#阻塞态">#</a> 阻塞态</h3><blockquote><p>在进程运行过程中，可能会请求等待某个事件的发生 (如等待某种系统资源の分配 or 等待其他进程的响应)<br /> 让这个进程下 CPU ，并让它进入 &quot;<strong> 阻塞态</strong> &quot;<br /> 当 CPU 空闲时，又会选择另一个 “<em>就绪态</em>” 进程上 CPU 运行</p></blockquote><h3 id="终止态"><a class="anchor" href="#终止态">#</a> 终止态</h3><blockquote><p>该进程可执行 exit 系统调用，请求操作系统终止该进程<br />此时该进程会进入 “<strong>终止态</strong>”，操作系统会让该进程下 CPU 并回收内存空间等资源，最后还要回收该进程的 PCB。<br />当终止进程的工作完成后，这个进程彻底消失了</p></blockquote><h2 id="状态间の转换"><a class="anchor" href="#状态间の转换">#</a> 状态间の转换</h2><p><a href="https://imgse.com/i/xq1cGD"><img data-src="https://s1.ax1x.com/2022/11/03/xq1cGD.png" alt="xq1cGD.png" /></a></p><p>进程 PCB 中，会有一个变量 state 来表示进程的当前状态</p><h2 id="进程的组织方式"><a class="anchor" href="#进程的组织方式">#</a> 进程的组织方式</h2><p><a href="https://imgse.com/i/xq3KJO"><img data-src="https://s1.ax1x.com/2022/11/03/xq3KJO.png" alt="xq3KJO.png" /></a></p><h1 id="进程控制"><a class="anchor" href="#进程控制">#</a> 进程控制</h1><p><a href="https://imgse.com/i/xqzXmn"><img data-src="https://s1.ax1x.com/2022/11/04/xqzXmn.md.png" alt="xqzXmn.md.png" /></a></p><h2 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h2><ul><li><p>WHAT：<br />进程控制的主要功能是对系统中所有进程 实施有效的管理，具有创建新进程、策划小已有新进程、实现进程状态转换等功能</p><p>实现进程状态的转换</p></li><li><p>如何实现：用<strong>原语</strong>实现<br />原语 是一种特殊的程序，它的执行具有原子性。<br /><a href="https://imgse.com/i/xqaPKO"><img data-src="https://s1.ax1x.com/2022/11/03/xqaPKO.png" alt="xqaPKO.png" /></a><br /><a href="https://imgse.com/i/xqa8aj"><img data-src="https://s1.ax1x.com/2022/11/03/xqa8aj.png" alt="xqa8aj.png" /></a><br /><a href="https://imgse.com/i/xqaNR0"><img data-src="https://s1.ax1x.com/2022/11/03/xqaNR0.png" alt="xqaNR0.png" /></a></p></li></ul><h2 id="进程控制相关的原语"><a class="anchor" href="#进程控制相关的原语">#</a> 进程控制相关的原语</h2><p>Tip：无论哪个进程控制原语，要做的就三件事</p><ol><li><p>更新 PCB 中信息 (修改进程状态 state)  保存 / 恢复运行环境</p><ul><li>所有的进程控制原语一定都会会修改进程状态标志</li><li>录夺当前运行进程的 CPU 使用权 必然需保存其运行环境</li><li>某些进程开始运行前必然要恢复其运行环境</li></ul></li><li><p>将 PCB 插入合适的队列</p></li><li><p>分配 / 回收资源</p></li></ol><h3 id="进程的创建"><a class="anchor" href="#进程的创建">#</a> 进程的创建</h3><p><a href="https://imgse.com/i/xLSek6"><img data-src="https://s1.ax1x.com/2022/11/04/xLSek6.md.png" alt="xLSek6.md.png" /></a></p><h3 id="进程的终止"><a class="anchor" href="#进程的终止">#</a> 进程的终止</h3><p><a href="https://imgse.com/i/xLSVTx"><img data-src="https://s1.ax1x.com/2022/11/04/xLSVTx.md.png" alt="xLSVTx.md.png" /></a></p><h3 id="进程的阻塞"><a class="anchor" href="#进程的阻塞">#</a> 进程的阻塞</h3><h3 id="进程的唤醒"><a class="anchor" href="#进程的唤醒">#</a> 进程的唤醒</h3><p><a href="https://imgse.com/i/xLSmtK"><img data-src="https://s1.ax1x.com/2022/11/04/xLSmtK.md.png" alt="xLSmtK.md.png" /></a></p><h3 id="进程的切换"><a class="anchor" href="#进程的切换">#</a> 进程的切换</h3><p><a href="https://imgse.com/i/xLSE01"><img data-src="https://s1.ax1x.com/2022/11/04/xLSE01.md.png" alt="xLSE01.md.png" /></a></p><h1 id="进程通信ipc"><a class="anchor" href="#进程通信ipc">#</a> 进程通信 (IPC)</h1><p>Inter-process Communication 两个进程之间产生 数据交互<br />进程 是分配系统资源的单位 (include 内存地址空间)，因此各进程拥有的<strong>内存地址空间相互独立</strong><br />为保证安全，一个进程不能直接访问另一个进程的地址空间</p><h2 id="共享存储"><a class="anchor" href="#共享存储">#</a> 共享存储</h2><p>为避免出错，各个进程对共享空间的<strong>访问</strong>应该是<strong>互斥</strong>的<br />各个进程可使用 OS 内核提供的同步互斥工具 (PV 操作)</p><ol><li>基于数据结构的共享<br />比如共享空间里只能放一个长度为 10 的数组。这种通信方式速度慢、限制多、是一种<strong>低级通信</strong>方式</li><li>基于存储区的共享<br /> OS 在内存中划出一块共享存储区，数据的形式、存放位置都由通讯进程控制，而不是 OS。这种共享方式速度很快，是一种<strong>高级通讯</strong>方式</li></ol><h2 id="消息传递"><a class="anchor" href="#消息传递">#</a> 消息传递</h2><p>进程间的数据交换以格式化的消息 (Message) 为单位<br />进程通过 OS 提供的 “发送消息 / 接收消息” 两个<strong>原语</strong>进行数据交换</p><ol><li>直接通信方式<br />消息发送进程要指明 接收进程的 ID<br /><a href="https://imgse.com/i/xL7pIH"><img data-src="https://s1.ax1x.com/2022/11/04/xL7pIH.png" alt="xL7pIH.png" /></a></li><li>间接通信方式<br />通过 “信箱” 作为中间实体进行消息传递<br /><a href="https://imgse.com/i/xLTfMV"><img data-src="https://s1.ax1x.com/2022/11/04/xLTfMV.png" alt="xLTfMV.png" /></a></li></ol><h2 id="管道通信"><a class="anchor" href="#管道通信">#</a> 管道通信</h2><blockquote><p><strong>管道</strong>是一个特殊的共享文件，又名 pipe 文件。其实就是在内存中开辟一个大小固定的内存缓冲区<br />写进程往管道写数据，即使管道没被写满，只要管道没空，读进程就可以从管道中读数据<br />都进程从管道中读数据，即使管道没被读空，只要管道没满，写进程就可以往管道中写数据</p></blockquote><ol><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则需要设置两个管道</li><li>各进程要<strong>互斥</strong>地访问管道 (由操作系统实现)</li><li>当管道<strong>写满</strong>时，<strong>写进程将阻塞</strong>，直到都进程将 管道中的数据取走，即可唤醒写进程</li><li>当管道<strong>读空</strong>时，<strong>读进程将阻塞</strong>，直到写进程往 管道中写入数据，即可唤醒读进程</li><li>管道中的数据一旦被读出，就彻底消失。<br />SO，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：</li></ol><ul><li><strong>一个管道允许多个写进程，一个读进程</strong> (14 年官方答案)</li><li>允许<strong>有多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据 (Linux の方案)</li></ul><h1 id="线程概念-多线程模型"><a class="anchor" href="#线程概念-多线程模型">#</a> 线程概念、多线程模型</h1><p><a href="https://imgse.com/i/xXRPxO"><img data-src="https://s1.ax1x.com/2022/11/06/xXRPxO.png" alt="xXRPxO.png" /></a><br /><a href="https://imgse.com/i/xL7LkQ"><img data-src="https://s1.ax1x.com/2022/11/04/xL7LkQ.png" alt="xL7LkQ.png" /></a><br /><a href="https://imgse.com/i/xLLhE8"><img data-src="https://s1.ax1x.com/2022/11/04/xLLhE8.png" alt="xLLhE8.png" /></a><br /> 可以把线程理解为 “轻量级进程”<br /><strong> 线程是一个基本的 CPU 执行单元</strong>，也是程序执行流的最小单位。<br />引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内使得一个进程内也可以并发处理各种任务 (如 tim 视频、文字聊天、传文件)</p><p>引入线程后，进程只作为除 COU 之外的系统资源的分配单元 (如 打印机、内存地址空间等 都是分配给进程的)</p><p>线程则作为<strong>处理机的分配单元</strong></p><h2 id="变化"><a class="anchor" href="#变化">#</a> 变化</h2><ol><li>资源分配、调度<ul><li>传统进程机制中，进程是 资源分配、调度的基本单位</li><li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul></li><li>并发性<ul><li>传统进程机制中，只能进程之间并发</li><li>引入线程后，各线程间也能并发，进程间也并发，提高了并发度</li></ul></li><li>系统开销<ul><li>传统进程间并发，需要切换进程的运行环境，系统开销很大</li><li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li><li>引入线程后，并发所带来的系统开销小</li></ul></li></ol><h2 id="属性"><a class="anchor" href="#属性">#</a> 属性</h2><ol><li>线程是处理机调度的单位</li><li>多 CPU 计算机中，各个线程可占用不同的 CPU</li><li>每个线程都有一个线程 ID 、线程控制块 (TCB)</li><li>线程也有 就绪、阻塞、运行 三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程の 不同线程间共享 进程の资源</li><li>由于共享内存地址空间，同一进程中の线程间通信甚至无需系统干预</li><li>同一进程间の线程切换 不会引起进程切换</li><li><strong>不同进程中の线程切换 会引起进程切换</strong></li><li>切换同进程内の线程，系统开销很小</li><li>切换进程，系统开销很大</li></ol><h1 id="线程的实现方式-多线程模型"><a class="anchor" href="#线程的实现方式-多线程模型">#</a> 线程的实现方式 &amp; 多线程模型</h1><h2 id="线程的实现方式"><a class="anchor" href="#线程的实现方式">#</a> 线程的实现方式</h2><h3 id="用户级线程"><a class="anchor" href="#用户级线程">#</a> 用户级线程</h3><p><a href="https://imgse.com/i/xOSRzD"><img data-src="https://s1.ax1x.com/2022/11/04/xOSRzD.png" alt="xOSRzD.png" /></a></p><ol><li>用户级线程由应用程序通过<strong>线程库</strong>实现，所有的<strong>线程管理工作</strong>都由应用程序负责 (包括 线程切换)</li><li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态下</strong>即可完成，无需操作系统干预</li><li>在用户看来，是由多个线程。但是在操作系统内核看来，并 意识不到线程の存在。<br />“用户级线程” 就是 “从用户视角能看到の线程”</li><li>优缺点：<ul><li>优点：用户级线程の切换 在用户空间即可完成，不需要切换到核心态，线程管理の系统开销小，效率高。</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。 多个线程不可在多核处理机上并行运行。</li></ul></li></ol><h3 id="内核级线程"><a class="anchor" href="#内核级线程">#</a> 内核级线程</h3><p><a href="https://imgse.com/i/xOS4Ld"><img data-src="https://s1.ax1x.com/2022/11/04/xOS4Ld.png" alt="xOS4Ld.png" /></a></p><ol><li>内核级线程の管理工作由<strong>操作系统内核</strong>完成</li><li>线程调度、切换等工作都由内核负责，so 内核级线程の切换必然需要在<strong>核心态</strong>下才能完成</li><li>操作系统 会为每个 内核级线程建立相应的 TCB (Thread control Block 线程控制块)，通过 TCB 对线程进行管理。“内核级线程” 就是 “从操作系统内核视角看 能看得到的线程”</li><li>优缺点：<ul><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。 多线程可在多核处理机上并发执行。</li><li>缺点：一个用户会占用多个内核级线程，线程切换由 OS 内核完成，需要切换到核心态，so 线程管理の成本高，开销大。</li></ul></li></ol><h2 id="多线程模型"><a class="anchor" href="#多线程模型">#</a> 多线程模型</h2><p>在支持内核级线程的系统中，根据用户级线程 and 内核级线程 の映射关系，可以划分为几种多线程模型</p><h3 id="一对一模型"><a class="anchor" href="#一对一模型">#</a> 一对一模型</h3><p><a href="https://imgse.com/i/xO9cvD"><img data-src="https://s1.ax1x.com/2022/11/04/xO9cvD.png" alt="xO9cvD.png" /></a><br /> 一个用户级线程 映射到 一个内核级线程。每个用户进程有与 用户级线程同数量の内核级线程</p><ul><li>优点：</li></ul><h3 id="多对一模型"><a class="anchor" href="#多对一模型">#</a> 多对一模型</h3><p><a href="https://imgse.com/i/xO9oPP"><img data-src="https://s1.ax1x.com/2022/11/04/xO9oPP.png" alt="xO9oPP.png" /></a></p><h3 id="多对多模型"><a class="anchor" href="#多对多模型">#</a> 多对多模型</h3><p><a href="https://imgse.com/i/xO9LrQ"><img data-src="https://s1.ax1x.com/2022/11/04/xO9LrQ.png" alt="xO9LrQ.png" /></a></p><p><a href="https://imgse.com/i/xOCSP0"><img data-src="https://s1.ax1x.com/2022/11/04/xOCSP0.png" alt="xOCSP0.png" /></a></p><h1 id="线程的状态与转换"><a class="anchor" href="#线程的状态与转换">#</a> 线程的状态与转换</h1><h2 id="状态与转换"><a class="anchor" href="#状态与转换">#</a> 状态与转换</h2><p><a href="https://imgse.com/i/xO2PLd"><img data-src="https://s1.ax1x.com/2022/11/05/xO2PLd.png" alt="xO2PLd.png" /></a></p><h2 id="组织与控制"><a class="anchor" href="#组织与控制">#</a> 组织与控制</h2><p><a href="https://imgse.com/i/xORd9f"><img data-src="https://s1.ax1x.com/2022/11/05/xORd9f.png" alt="xORd9f.png" /></a></p><h1 id="调度算法"><a class="anchor" href="#调度算法">#</a> 调度算法</h1><blockquote><p>Tips 作业调度 or 进程调度？ 抢占式 or 非抢占式？ 优缺点？<strong>是否导致饥饿？</strong></p></blockquote><h2 id="先来先服务fcfs"><a class="anchor" href="#先来先服务fcfs">#</a> 先来先服务 (FCFS)</h2><p><a href="https://imgse.com/i/xXMEfU"><img data-src="https://s1.ax1x.com/2022/11/05/xXMEfU.png" alt="xXMEfU.png" /></a></p><h2 id="短作业优先sjf"><a class="anchor" href="#短作业优先sjf">#</a> 短作业优先 (SJF)</h2><p><a href="https://imgse.com/i/xXMkkV"><img data-src="https://s1.ax1x.com/2022/11/05/xXMkkV.png" alt="xXMkkV.png" /></a><br /><a href="https://imgse.com/i/xXMZpF"><img data-src="https://s1.ax1x.com/2022/11/05/xXMZpF.png" alt="xXMZpF.png" /></a></p><h2 id="高响应比优先hrrn"><a class="anchor" href="#高响应比优先hrrn">#</a> 高响应比优先 (HRRN)</h2><p><a href="https://imgse.com/i/xXMAYT"><img data-src="https://s1.ax1x.com/2022/11/05/xXMAYT.png" alt="xXMAYT.png" /></a></p><p>！ 😂</p><table><thead><tr><th>算法</th><th>可抢占？</th><th>优点</th><th>缺点</th><th>考虑等待时间、运行时间</th><th>饥饿？   (某进程长期得不到服务)</th></tr></thead><tbody><tr><td>FCFS</td><td>非抢占式</td><td>公平；实现简单</td><td>对短作业不利、长作业有利</td><td>等待时间</td><td>不会</td></tr><tr><td>SJF/SPF</td><td>默认非抢占式 SJF/SPF  、抢占式 SRTN</td><td>拥有最短の平均等待时间、平均周转时间</td><td>对长作业不利、可能导致饥饿；难以做到真正の短作业优先</td><td>运行时间</td><td>会</td></tr><tr><td>HRRN</td><td>非抢占式</td><td>FCFS &amp; SJF の折中</td><td>😵</td><td>综合考虑等待时间、运行时间</td><td>不会</td></tr></tbody></table><blockquote><p>SJF/SPF 可用于 <strong>作业</strong>调度 job、<strong>进程</strong>调度 process   作业 / 进程の运行是由用户提供的，并不一定真实，不一定能做到真正的短作业优先<br /> S Remaining Time Next<br /><a href="https://imgse.com/i/xXQyUx"><img data-src="https://s1.ax1x.com/2022/11/05/xXQyUx.png" alt="xXQyUx.png" /></a></p></blockquote><h1 id="调度の层次-概念"><a class="anchor" href="#调度の层次-概念">#</a> 调度の层次、概念</h1><blockquote><p>作业：一个具体の任务<br />用户向系统提交一个作业～用户让 OS 启动一个程序 (来处理一个具体の任务)<br /> 挂起： 内存不够时，可将某些进程の数据调出外存。等 内存空闲 or 进程需要 运行时再重新调入内存。<br />暂时调到外存等待の进程状态 为 <strong>挂起状态</strong>。被挂起的进程 PCB 会被组织成<strong>挂起队列</strong>。<br />挂起态可分为：就绪挂起、阻塞挂起。<br />有的 OS 会把 就绪挂起、阻塞挂起 分为两个挂起队列，甚至会根据阻塞原因不同再把 阻塞挂起进一步细分为多个队列<br /><a href="https://imgse.com/i/xXfwb4"><img data-src="https://s1.ax1x.com/2022/11/06/xXfwb4.png" alt="xXfwb4.png" /></a></p></blockquote><h2 id="三个层次"><a class="anchor" href="#三个层次">#</a> 三个层次</h2><p><a href="https://imgse.com/i/xXhniR"><img data-src="https://s1.ax1x.com/2022/11/06/xXhniR.png" alt="xXhniR.png" /></a></p><ol><li><p>高级调度 (作业调度):<br /><strong> 外存 ---&gt; 内存</strong><br /><strong>按照某种规则，从后备队列中选择合适の作业将其调入内存，并为其创建进程。</strong><br />按一定的原则从 外存の作业后备队列中挑选一个作业 调入内存，并创建进程。 每个作业值调入一次，调出一次。 作业调入时 会创建 PCB，调出时 才撤销 PCB。</p></li><li><p>低级调度 (进程调度 / 处理机调度)：<br /><strong>内存 ---&gt;CPU</strong><br /><strong> 按照某种规则，从就绪队列中选择一个进程为其分配处理机。</strong><br />按照某种策略 从就绪队列中选取 一个进程，将处理机分配给它。<br />是 OS 中<strong>最基本の一种调度</strong>，在一般の OS 中都必须配置 进程调度。<br />进程调度の 频率很高，一般几十毫秒一次</p></li><li><p>中级调度 (内存调度)：<br /><strong>外存 ---&gt; 内存</strong><br /><strong>按照某种规则，从挂起队列中选择合适的进程 将其数据调回内存</strong><br />按照某种策略决定将哪个处于挂起状态の进程重新调入内存。<br />一个进程可能会被 多次调出、调入内存，因此<strong>中极调度</strong> 发生の频率要比高级调度更高。</p></li></ol><h1 id="进程互斥の软件实现方法"><a class="anchor" href="#进程互斥の软件实现方法">#</a> 进程互斥の软件实现方法</h1><h2 id="单标志法"><a class="anchor" href="#单标志法">#</a> 单标志法</h2><p>算法思想：两个进程在<em>访问完临界区后</em>会把使用临界区の权限 转交给另一个进程。<br />=<strong> 每个进程进入临界区の权限只能由另一个进程赋予</strong><br /> “同一时刻最多只允许一个进程访问临界区”</p><blockquote><p>未遵循 “空闲让进”<br /><a href="https://imgse.com/i/xXvRQe"><img data-src="https://s1.ax1x.com/2022/11/06/xXvRQe.png" alt="xXvRQe.png" /></a></p></blockquote><h2 id="双标志先检查"><a class="anchor" href="#双标志先检查">#</a> 双标志先检查</h2><blockquote><p>未遵循 “忙则等待”  (p0,p1 搞不好同时访问临界区)<br /><a href="https://imgse.com/i/xXvfLd"><img data-src="https://s1.ax1x.com/2022/11/06/xXvfLd.png" alt="xXvfLd.png" /></a></p></blockquote><h2 id="双标志后检查"><a class="anchor" href="#双标志后检查">#</a> 双标志后检查</h2><blockquote><p>未遵循 “空闲让进 、 有限等待” ，可能导致饥饿<br /><a href="https://imgse.com/i/xXvWsH"><img data-src="https://s1.ax1x.com/2022/11/06/xXvWsH.png" alt="xXvWsH.png" /></a></p></blockquote><h2 id="peterson算法"><a class="anchor" href="#peterson算法">#</a> Peterson 算法</h2><blockquote><p>遵循了 空闲让近、忙则等待、有限等待 三个原则，but 依未遵循 让权等待 原则<br /><a href="https://imgse.com/i/xXxj1O"><img data-src="https://s1.ax1x.com/2022/11/06/xXxj1O.png" alt="xXxj1O.png" /></a></p></blockquote><h1 id="进程互斥の硬件实现方法"><a class="anchor" href="#进程互斥の硬件实现方法">#</a> 进程互斥の硬件实现方法</h1><h2 id="中断屏蔽方法"><a class="anchor" href="#中断屏蔽方法">#</a> 中断屏蔽方法</h2><p>利用 “开 / 关中断指令” 实现 (与原语的实现思想相同，即 在某进程开始访问临近区到结束访问为止都不允许被中断，也就不能发生进程切换， 因此也不能发生两个同时 访问临界区的情况)</p><hr /><p>关中断；<br />临界区；<br />开中断；</p><hr /><p>优点：简单、高效<br />缺点：不适用于 多处理机；只适用于<strong>操作系统</strong>内核进程，不适用于 用户进程 (因为 开 / 关 中断指令只能运行在内核态， 这组指令如果能让用户随意使用会很危险)</p><h2 id="testandset指令"><a class="anchor" href="#testandset指令">#</a> TestAndSet 指令</h2><p>简称 TS、TSL 指令<br /> TSL 是用硬件实现的，执行过程中不允许被中断，只能一气呵成。<br />优点：适用于多处理机环境 实现简单、无需像软件方法严格检查是否有漏洞<br />缺点：不满足”<strong> 让权等待</strong> “原则，暂时无法进入临界区の进程会占用 CPU 并循环执行 TSL 指令，从而导致 “忙等”<br /><a href="https://imgse.com/i/xjQBmd"><img data-src="https://s1.ax1x.com/2022/11/06/xjQBmd.png" alt="xjQBmd.png" /></a></p><h2 id="swap指令"><a class="anchor" href="#swap指令">#</a> Swap 指令</h2><p>简称 Exchange XCHG 指令<br /> Swap 指令<strong>是用硬件实现の</strong>，执行过程中不允许被中断，只能一气呵成。<br />优点：适用于多处理机环境 实现简单、无需像软件方法严格检查是否有漏洞<br />缺点：不满足”<strong> 让权等待</strong> “原则，暂时无法进入临界区の进程会占用 CPU 并循环执行 TSL 指令，从而导致 “忙等”<br /><a href="https://imgse.com/i/xjlK4P"><img data-src="https://s1.ax1x.com/2022/11/06/xjlK4P.png" alt="xjlK4P.png" /></a></p><h1 id="互斥锁"><a class="anchor" href="#互斥锁">#</a> 互斥锁</h1><p>解决临界区最简单工具の就是<strong>互斥锁 (mutex lock)</strong> . 一个进程在进入临界区时应获得锁；在退出临界区时释放锁。 函数 acquire () 获得🔒，release () 释放🔒。<br />每个互斥锁有一个布尔变量 availabel, 表示🔒是否可用。</p><p>如果🔒是可用の，调用 acquire () 会成功，且🔒不再可用。当一个进程试图获取不可用的🔒时，会被阻塞，直到🔒被释放。</p><pre><code>  acquire()     while(!available)&#123;        ；                         //忙等待     available = false;            //获得锁     &#125;     release()&#123;     available = true;             //释放锁  &#125;</code></pre><p>acquire () 和 release () 的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p><p>互斥锁の主要缺点是<strong>忙等待</strong>，当有一个进程在临界区，任何其他进程在进入临界区时必须连续循环调用 acquire ()<br /> 当多个进程共享同一 CPU 时，就浪费了 CPU の生命周期。<br />因此，互斥锁 通常用于多处理系统，一个线程可以在一个处理器上等待，不影响其他线程の执行。</p><p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁 (spin lock)</strong>, 如 TSL、swap、单标志法</p><p>特性：</p><ul><li>需忙等，进程时间片用完才下 处理机，违反 “让权等待”</li><li>优点：等待期间不用切换上下文，多处理系统中，若上锁の时间短，则等待代价很低</li><li>常用于多处理系统，一个核忙等，其他核正常工作，并快速释放临界区</li><li>不太适用于单处理机系统，忙等の过程中不可能照常工作<br /><a href="https://imgse.com/i/xj8qa9"><img data-src="https://s1.ax1x.com/2022/11/06/xj8qa9.png" alt="xj8qa9.png" /></a></li></ul><h1 id="信号量机制"><a class="anchor" href="#信号量机制">#</a> 信号量机制</h1><p>1965，荷兰科学家 Dijkstra 提出の实现 “进程互斥、同步の方法”-- 信号量机制<br />用户进程可以通过使用 OS 提供の<strong>一对原语</strong>来对信号量进行操作，实现了进程互斥、进程同步。</p><p><strong>每个信号量至少记录 2 个信息：信号量的值 and 等待该信号量的进程队列 (queue PCB)</strong></p><p>(类 PASCAL 语言来描述)<br />semaphore = record<br />value: integer;<br />queue: ^PCB;<br />end;<br /> 其中 PCB 是进程控制块，是操作系统为每个进程建立的数据结构。</p><p><strong>信号量</strong>其实就是一个变量，一个信号量可 <strong>表示系统中某种资源の数量</strong>，如：系统中只有一台打印机，就可以设置一个处置为 1 的信号量。</p><p><strong>原语</strong>是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由<strong>关中断 / 开中断指令</strong>实现的。</p><p><strong>一对原语</strong>：wait (S) 原语 &amp; signal (S) 原语，原语可理解为自己写的函数，<strong>信号量 S</strong> 为函数调用时传入の参数。</p><p>wait、signal 原语常<strong>简称为 P、V 操作</strong>。平时常写为 P (S)、V (S)</p><h2 id="整型信号量"><a class="anchor" href="#整型信号量">#</a> 整型信号量</h2><p>用一个<strong>整数型变量</strong>作为信号量，用来表示系统中某种资源的数量。<br />与普通整数信号量の区别：对信号量的操作只有三种：初始化、P 操作、V 操作</p><pre><code>  Eg：某计算机系统有一台打印机  int S = 1;         //初始化整形信号量，表示打印机资源个数  void wait(int S)&#123;          //wait原语，相当于“ 进入区”     while( S &lt;=0 );     S = S - 1;  &#125;  void signal(int S)&#123;           //signal原语，相当于“ 退出区”     S = S + 1;  &#125;</code></pre><p>进程 pi<br />...<br />wait (s);          // 进入区，申请资源<br />使用资源...        // 临界区，访问资源<br /> signal (s);        // 退出区，释放资源<br />...</p><h2 id="记录型信号量"><a class="anchor" href="#记录型信号量">#</a> 记录型信号量</h2><p>整型信号量缺陷 存在 “忙等” 问题，-&gt;, 记录型 数据结构表示の<strong>信号量</strong>。</p><blockquote><p>信号量 value&gt;0，value 表示可用资源的数量；value&lt;0，value 表示因该类资源阻塞的进程数量。<br />// 记录型信号量の定义<br /> typedef struct {<br />int value;              // 剩余资源数<br /> struct process *L;      // 等待队列<br />} semaphore;</p></blockquote><pre><code>  void wait( semaphore S)&#123;     S.value--;     if(S.value &lt; 0)&#123;        block(S.L);  //如果剩余资源数不够，使用block原语使进程 运行态-&gt;阻塞态，并把挂到信号量S的等待(阻塞)队列中     &#125;  &#125;  void singal( semaphore S)&#123;     S.value++;     if(S.value &lt;= 0)&#123;        wakeup(S.L);  //释放资源后，若还有别的进程在等待这个资源，则使用wakeuo原语唤醒等待队列中的一个进程，该进程从 阻塞态-&gt;就绪态     &#125;  &#125;</code></pre><p>P 操作 S.value &lt;0 该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞，主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了 &quot;让权等待&quot; 原则，不会出现 “忙等” 现象。</p><h2 id="二进制信号量binary-semaphore"><a class="anchor" href="#二进制信号量binary-semaphore">#</a> 二进制信号量 (Binary Semaphore)</h2><p>只允许信号量取 0 or 1 值</p><h1 id="用信号量机制实现进程-互斥-同步-前驱关系"><a class="anchor" href="#用信号量机制实现进程-互斥-同步-前驱关系">#</a> 用信号量机制实现进程 互斥、同步、前驱关系</h1><p><strong>一个信号量对应一种资源</strong><br />信号量的值 = 这种资源的剩余数量 (信号量值 &lt; 0, 说明此时有进程在等待这种资源)<br /> P (S)-- 申请一个资源 S，若资源不够就阻塞等待<br /> V (S)-- 释放一个资源 S，若有进程在等待这个资源，则唤醒一个进程</p><h2 id="进程互斥"><a class="anchor" href="#进程互斥">#</a> 进程互斥</h2><p>basic：信号量 mutex 表示 “进入临界区的名额”</p><ol><li>分析并发进程的关键活动，划定临界区</li><li>设置<strong>互斥信号量</strong> mutex,<strong> 初值为 1</strong></li><li>在进入区 P (mutex)-- 申请资源</li><li>在退出区 V (mutex)-- 释放资源</li></ol><p>注意：对<strong>不同的临界资源</strong>需要<strong>设置不同的互斥信号量</strong><br />缺少 P (mutex) 就不能保证临界资源的互斥访问<br />缺少 V (mutex) 会导致资源永不被释放，等待进程永不被唤醒</p><pre><code>  //记录型信号量の定义  typedef struct&#123;     int value;              //剩余资源数     struct process *L;      //等待队列  &#125;semaphore;  //信号量机制实现互斥  semaphore mutex = 1;  P1()&#123;     ...     P(mutex);               //使用临界资源要加锁     临界区代码段...     V(mutex);               //解锁     ...  &#125;  P2()&#123;     ...     P(mutex);     临界区代码段...     V(mutex);     ...  &#125;</code></pre><h2 id="进程同步"><a class="anchor" href="#进程同步">#</a> 进程同步</h2><blockquote><p>要让各并发进程 按要求有序地推进</p></blockquote><ol><li>分析什么地方需要实现 “同步关系”，即必须保证 “一前一后” 执行的两个操作 (or 代码)</li><li>设置同步信号量 S，初值为 0</li><li>在 “前操作” 之后执行 V (S)</li><li>在 “后操作” 之前执行 P (S)<br /><a href="https://imgse.com/i/xzKBOe"><img data-src="https://s1.ax1x.com/2022/11/08/xzKBOe.png" alt="xzKBOe.png" /></a></li></ol><h2 id="进程前驱关系"><a class="anchor" href="#进程前驱关系">#</a> 进程前驱关系</h2><ol><li>要为每一对前驱关系各设置一个同步信号量</li><li>在 “前操作” 之后对相应的同步信号量执行 V 操作</li><li>在 “后操作” 之前对相应的同步信号两执行 P 操作</li></ol><p><a href="https://imgse.com/i/xzKgYt"><img data-src="https://s1.ax1x.com/2022/11/08/xzKgYt.png" alt="xzKgYt.png" /></a></p><h1 id="生产者消费者问题"><a class="anchor" href="#生产者消费者问题">#</a> 生产者消费者问题</h1><p>empty：空闲缓冲区の数量 初值 n<br />full：非空闲缓冲区の数量<br /><a href="https://imgse.com/i/zS5lhF"><img data-src="https://s1.ax1x.com/2022/11/09/zS5lhF.png" alt="zS5lhF.png" /></a><br /><a href="https://imgse.com/i/zAseVP"><img data-src="https://s1.ax1x.com/2022/11/14/zAseVP.jpg" alt="zAseVP.jpg" /></a><br /><a href="https://imgse.com/i/zAsVbt"><img data-src="https://s1.ax1x.com/2022/11/14/zAsVbt.jpg" alt="zAsVbt.jpg" /></a></p><h1 id="多生产者-多消费者"><a class="anchor" href="#多生产者-多消费者">#</a> 多生产者 - 多消费者</h1><h1 id="吸烟者问题"><a class="anchor" href="#吸烟者问题">#</a> 吸烟者问题</h1><h1 id="读者写者问题"><a class="anchor" href="#读者写者问题">#</a> 读者写者问题</h1><p>mutex (1):a semaphore which is used to ensure mutual exclusion when <em>readcount</em> is updated i.e. when any reader enters or exits from the critical section.<br /> 一个信号量，用于在 <em>readcount</em> 更新时确保互斥，即当任何阅读器进入或退出临界区时。</p><p>readcount (0): an integer variable that keeps track of <strong>how many processes are currently reading the object</strong>.<br /> 跟踪<strong>当前有多少进程正在读取对象</strong></p><p>wrt (1):a semaphore common to both reder and writer process.<br /><a href="https://imgse.com/i/zSoLfU"><img data-src="https://s1.ax1x.com/2022/11/09/zSoLfU.png" alt="zSoLfU.png" /></a></p><p><a href="https://imgse.com/i/zSTbDA"><img data-src="https://s1.ax1x.com/2022/11/09/zSTbDA.png" alt="zSTbDA.png" /></a><br /><a href="https://imgse.com/i/zSTHud"><img data-src="https://s1.ax1x.com/2022/11/09/zSTHud.png" alt="zSTHud.png" /></a></p><h1 id="哲学家进餐问题"><a class="anchor" href="#哲学家进餐问题">#</a> 哲学家进餐问题</h1><p><a href="https://imgse.com/i/zFzAk6"><img data-src="https://s1.ax1x.com/2022/11/13/zFzAk6.jpg" alt="zFzAk6.jpg" /></a><br />Declare condition self[5];<br />Allows philosopher i to delay when he is hungery but is unable to obtain chopsticks needed.</p><h1 id="管程"><a class="anchor" href="#管程">#</a> 管程</h1><h2 id="引入管程原因"><a class="anchor" href="#引入管程原因">#</a> 引入管程原因</h2><p>解决信号量机制存在的问题：编写程序困难、易出错<br />一种机制，让程序员写程序时不需再关注复杂的 PV 操作<br /> 1973 年，Brinch Hansen 首次再程序设计语言 (Pascal) 中引入 “管程” 成分 -- 一种高级同步机制</p><h2 id="管程的定义和基本特征"><a class="anchor" href="#管程的定义和基本特征">#</a> 管程的定义和基本特征</h2><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的 共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ol><h2 id=""><a class="anchor" href="#">#</a> </h2><h1 id="死锁的概念"><a class="anchor" href="#死锁的概念">#</a> 死锁的概念</h1><p>哲学家问题中，if 5 个哲学家都拿起了走手边的筷子。</p><ul><li>每个人都占有资源，同时又在等待另一个人手里的资源</li><li>在并发环境下，各进程因竞争资源而造成的一种<em>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进</em>的现象</li></ul><h2 id="死锁-饥饿-死循环"><a class="anchor" href="#死锁-饥饿-死循环">#</a> 死锁、饥饿、死循环</h2><ol><li>死锁：一定是 “循环等待对方手里的资源” 导致的，因此如果有死锁现象，那么<strong>至少有两个 or 两个以上的进程同时发生死锁</strong>.<br /> 发生死锁的进程一定处于<strong>阻塞态</strong>。</li><li>饥饿：<strong>可能只有一个进程发生饥饿</strong>。可能是<strong>阻塞态</strong> or<strong> 就绪态</strong>、(长期得不到需要的 I/O 设备、长期得不到处理机)</li><li>死循环：可能只有一个进程发生死循环。死循环的 进程可以上处理机运行 (可以是 运行态)。<br />由代码的逻辑错误导致的 | 是被管理者的问题 (程序员来解决)；<br />死锁 &amp; 饥饿 由于 OS 分配资源的策略不合理导致的 | 是管理者 (OS) 的问题 (OS 来解决)</li></ol><h2 id="死锁产生的必要条件"><a class="anchor" href="#死锁产生的必要条件">#</a> 死锁产生的必要条件</h2><p>(必须同时满足以下 4 个条件)</p><ol><li><p>互斥条件：只有对必须互斥使用的资源 的争抢才会导致死锁 (哲学家筷子、打印机设备...)。像内存、扬声器这种可以同时让多个进程使用的资源是不会导致死锁的 (因为进程不用阻塞等待这种资源)</p></li><li><p>不剥夺条件：进程所获得的资源在未使用之前，<strong> 不能由其他进程强行夺走</strong>，只能主动释放。</p></li><li><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放</p></li><li><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一进程 已获得的资源 同时被下一个进程所请求</p></li></ol><ul><li>补充：发生死锁时一定有<strong>循环等待</strong>，但是发生循环等待时未必死锁。<br />(<strong>循环等待</strong>是发生死锁的 必要不充分条件)</li></ul><p>如果同类资源数大于 1，则循环等待时，未必发生死锁。<br />如果系统中每类资源都只有一个，那就是 充要条件 了。</p><h2 id="when-deadlock-happen"><a class="anchor" href="#when-deadlock-happen">#</a> When deadlock happen ?</h2><p>in all, 对不可剥夺资源的不合理分配，可能导致死锁</p><ol><li><p>对系统资源的竞争。<br />各进程对不可剥夺の资源 (如打印机) 的竞争可能引起死锁，<br />对可剥夺资源 (CPU) 的竞争是不会引起死锁的。</p></li><li><p>进程推进顺序非法。<br />请求和释放资源的顺序不当<br />如：并发执行的进程 P1、P2，各自申请并占有了资源 R1,R2，之后 P1 又紧接着申请 R2，P2 又申请资源 R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</p></li><li><p>信号量的使用不当。<br />生产者 - 消费者问题中，如果互斥的 P 在 同步的 P 之前，就可能导致死锁 (互斥信号量、同步信号量 as 一种抽象的系统资源)</p></li></ol><h2 id="deadlock-的处理策略"><a class="anchor" href="#deadlock-的处理策略">#</a> deadlock 的处理策略</h2><ul><li>预防：破坏 4 个必要条件中的一个</li><li>避免：某种方法防止系统进入不安全状态，从而避免死锁 (银行家算法)</li><li>死锁的检测和解除：允许死锁发生、系统负责检测出死锁并解除</li></ul><h3 id="预防死锁"><a class="anchor" href="#预防死锁">#</a> 预防死锁</h3><ol><li>破坏互斥条件</li></ol><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致互锁</p><ul><li>将临界资源改为可共享的资源 (如 SPOOLing 技术)</li><li>缺点：可行性不高、很多时候无法破环互斥条件。</li></ul><p>(为了系统安全、很多地方还必须保护这种互斥性)</p><ol start="2"><li>破坏不剥夺 条件</li></ol><p>不剥夺条件：进程所获得的资源在未使用之前，不能由其他进程强行夺走</p><ol><li>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时重新申请。</li><li>当某个进程需要的资源被其他资源占有时，由 OS 协助将想要的资源强行剥夺。<br />this 一般要考虑各进程的优先级 (如:<strong> 剥夺调度方式</strong>，就是将处理机资源强行剥夺给优先级更高的进程使用)</li></ol><p>缺点：</p><ul><li>实现复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。 this 只适用于易保存 and 恢复状态的资源，如 CPU。</li><li>反复地申请 and 释放资源会增加系统的开销，降低系统的吞吐量。</li><li>对方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都由放弃，以后再重新申请。如果一直这样，会导致进程<strong>饥饿</strong></li></ul><ol start="3"><li>破坏请求和保持 条件<br />请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其它进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li></ol><ul><li>采用静态分配方法，即进程在运行前 一次申请完它需要的全部资源，在它的资源未满足之前，不让它投入运行。<br />一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的资源</li><li>缺点：有些资源可能只需要很短的时间，因此如果进程的整个运行时间一直都保持着所有资源，就会造成严重的资源浪费，资源利用率低。可能导致某些进程饥饿。</li></ul><ol start="4"><li>破坏 循环等待 条件<br />循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时 被下一个进程所请求。</li></ol><ul><li>可采用<strong>顺序资源分配法</strong>：给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源 (相同的资源) 一次申请完</li><li>缺点：不方便增加新设备、会导致资源浪费、用户编程麻烦<br /><a href="https://imgse.com/i/z3MtWF"><img data-src="https://s1.ax1x.com/2022/11/22/z3MtWF.jpg" alt="z3MtWF.jpg" /></a></li></ul><h1 id="避免死锁"><a class="anchor" href="#避免死锁">#</a> 避免死锁</h1><h2 id="安全序列"><a class="anchor" href="#安全序列">#</a> 安全序列</h2><h2 id="银行家算法"><a class="anchor" href="#银行家算法">#</a> 银行家算法</h2><h3 id="检测和解除"><a class="anchor" href="#检测和解除">#</a> 检测和解除</h3>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL(二) 关系数据库</title>
      <link href="/2022/11/02/SQL-%E4%BA%8C-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/11/02/SQL-%E4%BA%8C-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>简介：提出关系模型的是美国 IBM 公司的 E.F.Codd</p><ul><li>1970 年提出关系数据模型</li><li>after , 提出了<strong>关系代数</strong> and<strong> 关系演算</strong>的概念</li><li>1972 提出了关系的 第一、第二、第三范式</li><li>1974 提出了关系的 BC 范式</li></ul><h1 id="关系数据结构及形式化定义"><a class="anchor" href="#关系数据结构及形式化定义">#</a> 关系数据结构及形式化定义</h1><h2 id="关系"><a class="anchor" href="#关系">#</a> 关系</h2><pre><code>关系 ：单一的数据结构 。 现实世界的实体 及 实体间的各种联系均用关系来表示。二维表 ： 逻辑结构。     从用户角度，关系模型中的数据结构 是一张二维表。建立在集合代数的基础上。</code></pre><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>域 (Domain)</td><td>一组具有相同数据类型的集合</td></tr><tr><td>笛卡尔积 (Cartesian Product)</td><td>所有域所有取值的一个组合 ；不能重复</td></tr><tr><td>关系 (Relation)</td><td></td></tr></tbody></table><h3 id="域domain"><a class="anchor" href="#域domain">#</a> 域 (Domain)</h3><h4 id="一组具有相同数据类型的集合"><a class="anchor" href="#一组具有相同数据类型的集合">#</a> 一组具有相同数据类型的集合</h4><h3 id="笛卡尔积cartesian-product"><a class="anchor" href="#笛卡尔积cartesian-product">#</a> 笛卡尔积 (Cartesian Product)</h3><pre><code>from itertools import productfor x,y,z in product(['a','b','c'],['d','e','f'],['m','n']):    print(x,y,z)  </code></pre><p><a href="https://imgse.com/i/xHqMAH"><img data-src="https://s1.ax1x.com/2022/11/02/xHqMAH.png" alt="xHqMAH.png" /></a></p><ul><li>元组 (Tuple)<br /><a href="https://imgse.com/i/xHLS2t"><img data-src="https://s1.ax1x.com/2022/11/02/xHLS2t.png" alt="xHLS2t.png" /></a><ul><li>笛卡尔积中每一元素 (d1,d2,...,dn) 叫做一个 n 元组 (n-tuple) or 简称元组</li><li>(张青梅，计算机专业，李勇)</li></ul></li><li>分量 (Component)<ul><li>笛卡尔积元素 (d1,d2,...,dn) 中的每一个值 di 叫做一个分量。</li><li>张青梅、计算机专业、...</li></ul></li><li>基数 (Cardinal number)<ul><li><a href="https://imgse.com/i/xHLXLT"><img data-src="https://s1.ax1x.com/2022/11/02/xHLXLT.png" alt="xHLXLT.png" /></a></li></ul></li><li>笛卡尔积的表示方法<ul><li>可 一个二维表</li><li>每行对应一个元组，每列对应一个域</li><li><a href="https://imgse.com/i/xHOGm8"><img data-src="https://s1.ax1x.com/2022/11/02/xHOGm8.png" alt="xHOGm8.png" /></a></li></ul></li></ul><h3 id="关系relation"><a class="anchor" href="#关系relation">#</a> 关系 (Relation)</h3><h4 id="关系-2"><a class="anchor" href="#关系-2">#</a> 关系</h4><p><a href="https://imgse.com/i/xHO0lq"><img data-src="https://s1.ax1x.com/2022/11/02/xHO0lq.png" alt="xHO0lq.png" /></a></p><h4 id="元组"><a class="anchor" href="#元组">#</a> 元组</h4><p>关系中的每个元素是关系中的元组，通常用<strong> t</strong> 表示。</p><h4 id="单元关系-与-二元关系"><a class="anchor" href="#单元关系-与-二元关系">#</a> 单元关系 与 二元关系</h4><ul><li>n=1, 单元关系 (Unary relation) or 一元关系</li><li>n=2, 二元关系 (Binary relation)</li></ul><h4 id="关系的表示"><a class="anchor" href="#关系的表示">#</a> 关系的表示</h4><p>关系也是一个二维表，每行对应一个元组，每列对用一个域<br /><a href="https://imgse.com/i/xHOonK"><img data-src="https://s1.ax1x.com/2022/11/02/xHOonK.png" alt="xHOonK.png" /></a></p><h4 id="属性"><a class="anchor" href="#属性">#</a> 属性</h4><ul><li>关系中不同列可对应相同的域</li><li>为区分，必须对每列起一个名字，成为属性</li><li>n 目关系必有 n 个属性</li></ul><h4 id="码"><a class="anchor" href="#码">#</a> 码</h4><ul><li><p>候选码 (Candidate Key)</p><ul><li>若关系中的某一属性组的值能唯一地标识一个元组，则称<strong>该属性组</strong>为候选码</li><li>简单的情况：候选码只包含一个属性</li></ul></li><li><p>全码 (All-key)</p><ul><li>最极端的情况：关系模式中的所有属性组是这个关系模式的候选码，成为全码。</li></ul></li><li><p>主码</p><ul><li>若一个关系有多个候选码，则选定其中一个为主码 (Primary key)</li></ul></li><li><p>主属性</p><ul><li>候选码的诸属性成为<strong>主属性</strong> (Prime attribute)</li><li>不包含任何候选码的属性成为非主属性 (None-Prime attribute) or 非码属性</li><li><a href="https://imgse.com/i/xHXMEF"><img data-src="https://s1.ax1x.com/2022/11/02/xHXMEF.md.png" alt="xHXMEF.md.png" /></a></li></ul></li></ul><h4 id="三类关系"><a class="anchor" href="#三类关系">#</a> 三类关系</h4><ul><li><strong>基本关系</strong> (基本表 or 基表): 实际存在的表，是实际存储数据的逻辑表示。</li><li><strong>查询表</strong>：查询结果对应的表。</li><li><strong>视图表</strong>：是虚表，由基本表 or 其他试图表导出的表，不对应实际存储的数据。</li></ul><h4 id="基本关系的性质"><a class="anchor" href="#基本关系的性质">#</a> 基本关系的性质</h4><ul><li>列是同质的 (Homogeneous)</li><li>不同的列可出自同一个域</li><li>其中的每一列称为一个属性</li><li>不同的属性要给予不同的属性名</li><li>列的顺序无所谓，列的次序可任意交换。</li><li>行的顺序无所谓，行的次序可以任意交换。</li><li><strong>任意两个元组的候选码不能相同</strong></li><li>分量必须取原子值（most basic）<ul><li><a href="https://imgse.com/i/xHXqbT"><img data-src="https://s1.ax1x.com/2022/11/02/xHXqbT.png" alt="xHXqbT.png" /></a></li></ul></li></ul><h2 id="关系模式"><a class="anchor" href="#关系模式">#</a> 关系模式</h2><h3 id="what-关系模式"><a class="anchor" href="#what-关系模式">#</a> What 关系模式</h3><ul><li>关系模式 Relation Schema 是型</li><li>关系是值</li><li>关系模式是对关系的描述<ul><li>元组集合的结构</li><li>属性构成</li><li>属性来自的域</li><li>属性与域之间的映象关系</li></ul></li></ul><h3 id="定义-关系模式"><a class="anchor" href="#定义-关系模式">#</a> 定义 关系模式</h3><ul><li><a href="https://imgse.com/i/xHjroF"><img data-src="https://s1.ax1x.com/2022/11/02/xHjroF.png" alt="xHjroF.png" /></a></li><li><a href="https://imgse.com/i/xHjyi4"><img data-src="https://s1.ax1x.com/2022/11/02/xHjyi4.png" alt="xHjyi4.png" /></a></li><li><a href="https://imgse.com/i/xHjgzR"><img data-src="https://s1.ax1x.com/2022/11/02/xHjgzR.png" alt="xHjgzR.png" /></a></li></ul><h3 id="关系模式与关系"><a class="anchor" href="#关系模式与关系">#</a> 关系模式与关系</h3><ul><li><p>关系模式：</p><ul><li>对关系的描述</li><li>静态的、稳定的</li></ul></li><li><p>关系：</p><ul><li>关系模式在某一时刻的状态 or 内容</li><li>动态的、随时间不断变化的</li></ul></li><li><p>关系模式和关系往往统称为关系</p></li></ul><h2 id="关系数据库"><a class="anchor" href="#关系数据库">#</a> 关系数据库</h2><p>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</p><h3 id="关系数据库の型与值"><a class="anchor" href="#关系数据库の型与值">#</a> 关系数据库の<strong>型</strong>与<strong>值</strong></h3><ol><li>关系数据库的型：关系数据库模式  对关系数据库的描述</li><li>关系数据库模式包括：<ul><li>若干域の定义</li><li>在这些域上定义の若干关系模式</li></ul></li><li>关系数据库の值：<ul><li>关系模式在某一时刻对应の关系の集合</li></ul></li></ol><h1 id="关系操作"><a class="anchor" href="#关系操作">#</a> 关系操作</h1><h2 id="基本关系操作"><a class="anchor" href="#基本关系操作">#</a> 基本关系操作</h2><h3 id="常用关系操作"><a class="anchor" href="#常用关系操作">#</a> 常用关系操作</h3><ul><li><strong>查询</strong>：选择、投影、连接、除、并、交、差</li><li><strong>数据更新</strong>：插入、删除、修改</li><li>查询的表达能力是其中最主要的部分</li><li><strong>选择、投影、并、差、笛卡尔积 是 5 种基本操作</strong></li></ul><h3 id="关系操作の特点"><a class="anchor" href="#关系操作の特点">#</a> 关系操作の特点：</h3><ul><li>集合操作方式：操作的对象和结果都是集合，一次一集合の方式</li></ul><h2 id="关系数据库语言の分类"><a class="anchor" href="#关系数据库语言の分类">#</a> 关系数据库语言の分类</h2><ul><li><p>关系代数语言：用对关系の运算来表达查询要求</p><ul><li>代表：ISBL</li></ul></li><li><p>关系演算语言：用为此来表达查询要求</p><ul><li>元组关系演算语言：<ul><li>谓词变元の基本对象是元组变量</li><li>代表：APLAHA,QUEL</li></ul></li><li>域关系演算语言：<ul><li>谓词变元の基本对象是域变量</li><li>代表：QBE</li></ul></li></ul></li><li><p>具有关系代数 and 关系演算双重特点の语言</p><ul><li>代表：SQL</li></ul></li></ul><h1 id="关系的完整性"><a class="anchor" href="#关系的完整性">#</a> 关系的完整性</h1><h2 id="关系の三类完整性约束"><a class="anchor" href="#关系の三类完整性约束">#</a> 关系の三类完整性约束</h2><p>1). 实体完整性<br /> 2). 参照完整性</p><p>关系模型必须满足の完整性约束条件 称为关系の两个<strong>不变性</strong>，应该由关系系统自动支持</p><p>3). 用户定义の完整性<br />应用领域需要遵循の约束条件，体现了具体领域中の语义约束</p><h2 id="实体完整性"><a class="anchor" href="#实体完整性">#</a> 实体完整性</h2><p><strong>规则 2.1 实体完整性规则 (Entity Integrity)</strong><br /> 若属性 A 是基本关系 R 的主属性，则属性 A 不能取空值<br />例子：<br />SAP(SUPERVISOR, SPECIALITY, POSTGRADUATE)<br />POSTGRADUATE:<br /> 主码 (假设研究生不会重名)<br /> 不能取空值</p><p>规则说明：</p><ol><li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li><li>现实世界中的实体是可区分的，即它们具有某种唯一性标识</li><li>关系模型中以主码作为唯一标识</li><li>主码的属性即主属性不能取空值<br />主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与 2) 矛盾，因此这个规则称为实体完整性</li></ol><h2 id="参照完整性"><a class="anchor" href="#参照完整性">#</a> 参照完整性</h2><h3 id="关系间的引用"><a class="anchor" href="#关系间的引用">#</a> 关系间的引用</h3><p>关系模型中实体与实体间的联系都是用关系来描述的，因此肯存在着关系与关系间的引用<br />例子：<br />学生 (<strong>学号</strong>，姓名，性别，<strong>专业号</strong>，年龄)  #学号是主码<br />专业 (<strong>专业号</strong>，专业名)                     #专业号是主码</p><p>学生关系引用了 专业关系的主码 “专业号”<br /> 学生关系中的 “专业号” 值 必须是确实存在的 专业的专业号，即专业<br />关系中有该专业的记录</p><p>例 2：学生、课程、学生与课程之间多对多联系<br />学生 (<strong>学号</strong>，姓名，性别，专业号，年龄)<br /> 课程 (<strong>课程号</strong>，课程名，学分)<br /> 选修 (<strong>学号</strong>，<strong>课程号</strong>，成绩)</p><p>例 3：学生实体及其内部的一对多联系<br /><a href="https://imgse.com/i/zSaqTx"><img data-src="https://s1.ax1x.com/2022/11/09/zSaqTx.png" alt="zSaqTx.png" /></a><br /> “学号” 是主码，“班长” 是外码，它引用了本关系的 “学号”<br />“班长” 必须是确实存在的学生的 学生的学号</p><h3 id="外码"><a class="anchor" href="#外码">#</a> 外码</h3><p>H<sub>2</sub>O<br />K<sub>s</sub></p><ul><li>设<em> F</em> 是基本关系<em> R</em> 的一个 or 一组属性，但不是关系<em> R</em> 的码<br />如果<em> F</em> 与基本关系<em> S</em> 的主码 K<sub>s</sub> 相对应，则称 F 是基本关系 R 的外码</li><li>基本关系<em> R</em> 称为<strong>参照关系</strong> (Referencing Relation)</li><li>基本关系<em> S</em> 称为<strong>被参照关系</strong> (Referenced Relation) or <strong>目标关系</strong> (Target Relation)</li></ul><p>例 1：<br />学生关系的 专业号 与专业关系的主码 专业号 相对应</p><ul><li>” 专业号 “属性是学生关系的外码</li></ul><h3 id="参照完整性规则"><a class="anchor" href="#参照完整性规则">#</a> 参照完整性规则</h3><h2 id="用户定义の完整性"><a class="anchor" href="#用户定义の完整性">#</a> 用户定义の完整性</h2><h1 id="关系代数"><a class="anchor" href="#关系代数">#</a> 关系代数</h1><h2 id="传统的集合运算"><a class="anchor" href="#传统的集合运算">#</a> 传统的集合运算</h2><h3 id="并union"><a class="anchor" href="#并union">#</a> 并 (Union)</h3><h3 id="差difference"><a class="anchor" href="#差difference">#</a> 差 (Difference)</h3><h3 id="交intersection"><a class="anchor" href="#交intersection">#</a> 交 (Intersection)</h3><h3 id="笛卡尔积cartesian-product-2"><a class="anchor" href="#笛卡尔积cartesian-product-2">#</a> 笛卡尔积 (Cartesian Product)</h3><h2 id="专门的关系运算"><a class="anchor" href="#专门的关系运算">#</a> 专门的关系运算</h2><h3 id="选择"><a class="anchor" href="#选择">#</a> 选择</h3><h3 id="投影"><a class="anchor" href="#投影">#</a> 投影</h3><h3 id="连接"><a class="anchor" href="#连接">#</a> 连接</h3><h3 id="除"><a class="anchor" href="#除">#</a> 除</h3><h1 id="关系演算"><a class="anchor" href="#关系演算">#</a> 关系演算</h1><h1 id="小结"><a class="anchor" href="#小结">#</a> 小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ML</title>
      <link href="/2022/10/30/ML/"/>
      <url>/2022/10/30/ML/</url>
      
        <content type="html"><![CDATA[<h1 id="ch_1-basic"><a class="anchor" href="#ch_1-basic">#</a> CH_1 basic</h1><p>什么是 ML?</p><ul><li>机械式的复述</li><li>“举一反三” 是机器学习的目标</li><li>一旦机器具有了 “举一反三” 能力，就可以高效地替代人完成类似工作。</li></ul><p>ML の发展</p><ul><li>ML 诞生的标志是 1959 年 IBM 公司的计算机科学家 亚瑟・塞缪尔 编写的一个跳棋程序</li><li>近年来异常火热，在学术界得到特别重视，在产业界更是得到广泛应用，涉及到欺诈检测、客户定位、产品推荐、实时工业监控、自动驾驶、人脸识别、情感分析和医疗诊断等领域。</li></ul><p>1950，马文・明斯 &amp; 邓恩・埃德蒙 建造了世界上第一台神经网络计算机<br /> 1956，约翰・麦卡锡提出了 “人工智能” 一词<br /><a href="https://imgse.com/i/zVQp9K"><img data-src="https://s1.ax1x.com/2022/11/15/zVQp9K.jpg" alt="zVQp9K.jpg" /></a></p><h1 id="pca_"><a class="anchor" href="#pca_">#</a> PCA_</h1><p><a href="https://imgse.com/i/xIXxEj"><img data-src="https://s1.ax1x.com/2022/10/30/xIXxEj.png" alt="PCA" /></a></p><h2 id="step"><a class="anchor" href="#step">#</a> Step</h2><h3 id="1对所有样本进行中心化"><a class="anchor" href="#1对所有样本进行中心化">#</a> 1. 对所有样本进行中心化：</h3><h3 id="2计算样本协方差矩阵"><a class="anchor" href="#2计算样本协方差矩阵">#</a> 2. 计算样本协方差矩阵</h3><h3 id="3对协方差矩阵做特征值分解"><a class="anchor" href="#3对协方差矩阵做特征值分解">#</a> 3. 对协方差矩阵做特征值分解</h3><h3 id="4取最大的m个特征值所对应的单位特征向量w1w2w3wn"><a class="anchor" href="#4取最大的m个特征值所对应的单位特征向量w1w2w3wn">#</a> 4. 取最大的 m 个特征值所对应的单位特征向量 W1,W2,W3...Wn</h3>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/2022/10/26/SQL/"/>
      <url>/2022/10/26/SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a class="anchor" href="#第一章">#</a> 第一章</h1><h2 id="1数据库系统概述"><a class="anchor" href="#1数据库系统概述">#</a> 1. 数据库系统概述</h2><h3 id="1四个基本概念"><a class="anchor" href="#1四个基本概念">#</a> 1. 四个基本概念</h3><h4 id="数据-data"><a class="anchor" href="#数据-data">#</a> 数据 Data</h4><ul><li>是数据库中存储的基本对象。</li><li>特点：数据与其语义是不可分的。</li></ul><h4 id="数据库-db"><a class="anchor" href="#数据库-db">#</a> 数据库 DB</h4><ul><li>是长期存储在计算机内、有组织的、可共享的 大量数据的集合。</li><li>基本特征：数据按一定的数据模型组织、描述和存储。<ul><li>可为各种用户共享。</li><li>冗余度较小。</li><li>数据独立性较高。</li><li>易拓展。</li></ul></li></ul><h4 id="数据库管理系统-dbms"><a class="anchor" href="#数据库管理系统-dbms">#</a> 数据库管理系统 DBMS</h4><ul><li><p>位于用户与操作系统之间的一层 数据管理软件。</p></li><li><p>是基础软件，是一个大型复杂的软件系统</p></li><li><p>用途：科学地组织和存储数据、高效地获取和维护数据</p></li><li><p>数据定义功能：提供数据定义语言 (DDL)。 定义数据库中的数据对象</p></li><li><p>数据组织、存储和管理：</p><ul><li>分类组织、存储和管理各种数据</li><li>确定 组织数据的文件结构和存取方式</li><li>实现数据之间的联系</li><li>提供多种存取方法提高存取效率</li></ul></li><li><p>数据操纵功能：</p><ul><li>提供数据操纵语言 (DML)</li><li>实现对数据库的基本操作 (查询、插入、删除 and 修改)</li></ul></li><li><p>数据库的事务管理和运行管理：</p><ul><li>数据库在建立、运行和维护时由 DBMS 统一管理和控制<br />保证数据的安全性、完整性、多用户对数据的并发使用发生故障后的系统恢复。</li></ul></li><li><p>数据库的建立和维护功能 (实用程序)</p><ul><li>数据库初始数据装载转换</li><li>数据库转储</li><li>介质故障恢复</li><li>数据库 的重组织</li><li>性能监视分析 etc</li></ul></li><li><p>其他功能：</p><ul><li>DBMS 与网络中其它软件系统的通信</li><li>两个 DBMS 系统的数据转换</li><li>异构数据库之间的互访和互操作</li></ul></li></ul><h4 id="数据库系统-dbs"><a class="anchor" href="#数据库系统-dbs">#</a> 数据库系统 DBS</h4><ul><li>在计算机系统中引入数据库后的系统构成</li><li>数据库系统构成：<ul><li>数据库</li><li>数据库管理系统 (及其开发工具)</li><li>应用系统</li><li>数据库管理员</li></ul></li></ul><h3 id="2数据库系统的特点"><a class="anchor" href="#2数据库系统的特点">#</a> 2. 数据库系统的特点</h3><ul><li><p>数据结构化</p></li><li><p>数据的共享性高，冗余度低，易扩充</p></li><li><p>数据独立性高：</p></li></ul><ol><li>物理独立性<br />物理存储改变了，应用程序不改变</li><li>逻辑独立性</li></ol><ul><li>数据由 DBMS 统一管理和控制</li></ul><ol><li><p>数据独立性是由 DBMS 的二级映像功能来保证的</p></li><li><p>DBMS 提供的数据控制功能</p><p>(1). 数据的安全性保护<br /> (2). 数据的完整性 (Integrity) 检查<br /> (3). 并发 (Concurrency) 控制<br /> (4). 数据库恢复</p></li></ol><h2 id="2数据模型"><a class="anchor" href="#2数据模型">#</a> 2. 数据模型</h2><p>分两类，分属两个不同的层次</p><h3 id="概念模型信息模型"><a class="anchor" href="#概念模型信息模型">#</a> 概念模型 (信息模型)</h3><p>按 用户的观点 来对数据和信息建模，用于数据库设计。</p><p>现实世界中的客观对象抽象为<strong>概念模型</strong><br />把概念模型转换为某一 DBMS 支持的数据模型</p><h3 id="逻辑模型-and-物理模型"><a class="anchor" href="#逻辑模型-and-物理模型">#</a> 逻辑模型 and 物理模型</h3><ul><li>逻辑模型：主要包括网状模型、层次模型、关系模型、面向对象模型，<br /> 按<strong>计算机系统的观点对数据建模，用于 DBMS 实现</strong></li><li>物理模型：对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。<br /><a href="https://imgse.com/i/x4s7ff"><img data-src="https://s1.ax1x.com/2022/10/28/x4s7ff.png" alt="两步抽象.png" /></a></li></ul><h3 id="1数据模型的组成要素"><a class="anchor" href="#1数据模型的组成要素">#</a> 1. 数据模型的组成要素</h3><h4 id="1数据结构"><a class="anchor" href="#1数据结构">#</a> (1) 数据结构</h4><h4 id="2数据操作"><a class="anchor" href="#2数据操作">#</a> (2) 数据操作</h4><ul><li>查询</li><li>更新 (包括插入、删除、修改)</li></ul><h4 id="3完整性约束条件"><a class="anchor" href="#3完整性约束条件">#</a> (3) 完整性约束条件</h4><ul><li>一组完整性规则的集合</li><li>完整性规则：给定的数据模型中数据及其联系所具有的制约和存储规则</li><li>用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</li><li><strong>完整定义</strong>：<br />(1). 反应和规定本数据模型必须遵守的基本的通用的完整性约束条件。<br />eg：在关系模型中，任何关系必须满足 [实体完整性] 和 [参照完整性] 两个条件。<br />(2). 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</li></ul><h3 id="2概念模型"><a class="anchor" href="#2概念模型">#</a> 2. 概念模型</h3><h4 id="1信息世界中的基本概念"><a class="anchor" href="#1信息世界中的基本概念">#</a> 1. 信息世界中的基本概念</h4><blockquote><p>实体 (Entity)：    客观存在并可互相区别的事物。可以是 具体的人、事、物 or 抽象的概念<br />属性 (Attribute): 实体具有的某一特征。一个实体可由若干个属性来刻画。<br />码 (Key): 唯一标识实体的属性集。<br />域 (Domain): 属性的取值范围<br />实体型 (Entity Type): 用实体名及其属性名集合 来抽象和刻画同类实体<br />实体集 (Entity Set): 同一类型实体的集合<br />联系 (Relationship):</p><blockquote><p>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系 and 实体之间的联系。<br /><strong>实体内部</strong>的联系通常是指组成实体的各属性之间的联系<br /><strong>实体之间</strong>的联系通常是指不同实体集之间的联系</p></blockquote></blockquote><h4 id="2两个实体型之间的联系"><a class="anchor" href="#2两个实体型之间的联系">#</a> 2. 两个实体型之间的联系</h4><p><a href="https://imgse.com/i/x52D91"><img data-src="https://s1.ax1x.com/2022/10/29/x52D91.png" alt="两个实体型之间的联系" /></a></p><h4 id="3两个以上实体型之间的联系"><a class="anchor" href="#3两个以上实体型之间的联系">#</a> 3. 两个以上实体型之间的联系</h4><p><a href="https://imgse.com/i/x5Rc2q"><img data-src="https://s1.ax1x.com/2022/10/29/x5Rc2q.png" alt="两个以上实体型之间的联系" /></a></p><h4 id="4单个实体型内的联系"><a class="anchor" href="#4单个实体型内的联系">#</a> 4. 单个实体型内的联系</h4><p><a href="https://imgse.com/i/x5RHR1"><img data-src="https://s1.ax1x.com/2022/10/29/x5RHR1.png" alt="单个实体型内的联系" /></a></p><h4 id="5概念模型的一种表示方法"><a class="anchor" href="#5概念模型的一种表示方法">#</a> 5. 概念模型的一种表示方法</h4><p>E-R 图</p><h4 id="6一个实例"><a class="anchor" href="#6一个实例">#</a> 6. 一个实例</h4><p><a href="https://imgse.com/i/x5RzIH"><img data-src="https://s1.ax1x.com/2022/10/29/x5RzIH.png" alt="" /></a></p><h3 id="3最常用的数据模型"><a class="anchor" href="#3最常用的数据模型">#</a> 3. 最常用的数据模型</h3><h4 id="1非关系模型"><a class="anchor" href="#1非关系模型">#</a> 1. 非关系模型</h4><ul><li>层次模型 (Hierarchical Model)</li><li>网状模型 (Network Model)</li></ul><h4 id="2关系模型relational-model"><a class="anchor" href="#2关系模型relational-model">#</a> 2. 关系模型 (Relational Model)</h4><h4 id="3面向对象模型object-oriented-model"><a class="anchor" href="#3面向对象模型object-oriented-model">#</a> 3. 面向对象模型 (Object Oriented Model)</h4><h4 id="4对象关系模型object-relational-model"><a class="anchor" href="#4对象关系模型object-relational-model">#</a> 4. 对象关系模型 (Object Relational Model)</h4><h3 id="4层次模型"><a class="anchor" href="#4层次模型">#</a> 4. 层次模型</h3><p>是数据库系统中最早出现的 数据模型，典型代表：IBM 公司的 IMS (info Management System) 数据库管理系统；用<strong>树形结构</strong>来表示各类实体以及实体间的联系。</p><h4 id="1层次模型的数据结构"><a class="anchor" href="#1层次模型的数据结构">#</a> 1. 层次模型的数据结构</h4><ul><li>满足 de 集合：<ul><li>根节点 (有且只有一个结点 没有双亲结点)</li><li>根以外的其它结点有且只有一个双亲结点</li></ul></li><li>术语：根节点，双亲结点，兄弟结点，叶结点</li></ul><h4 id="2多对多联系在层次模型中的表示"><a class="anchor" href="#2多对多联系在层次模型中的表示">#</a> 2. 多对多联系在层次模型中的表示</h4><ul><li>方法：多对多联系分解成一对多联系</li><li>分解方法：<ul><li>冗余结点法</li><li>虚拟结点法</li></ul></li></ul><h4 id="3层次模型的数据操纵与完整性约束"><a class="anchor" href="#3层次模型的数据操纵与完整性约束">#</a> 3. 层次模型的数据操纵与完整性约束</h4><ul><li><p>层次模型的数据操纵</p><ul><li>查询</li><li>插入</li><li>删除</li><li>更新</li></ul></li><li><p>层次模型的完整性约束条件</p></li></ul><h4 id="4层次模型的存储结构"><a class="anchor" href="#4层次模型的存储结构">#</a> 4. 层次模型的存储结构</h4><blockquote><p><strong>邻接法</strong>： 按照树的前序遍历 ----&gt; 依次邻接存放，即通过物理空间的位置相邻来实现层次谁徐<br /><strong>链接法</strong>：(用来反映数据之间的层次关系)</p><blockquote><p>子女 - 兄弟链接法：<br />层次序列链接法：<br /><a href="https://imgse.com/i/x5IaMn"><img data-src="https://s1.ax1x.com/2022/10/29/x5IaMn.png" alt="" /></a></p></blockquote></blockquote><h4 id="5优缺点"><a class="anchor" href="#5优缺点">#</a> 5. 优缺点：</h4><p>优点：<br />数据结构简单清晰<br />查询效率高，性能 优于关系模型，不低于 网状模型<br />提供了良好的完整性支持</p><p>缺点：<br />多对多联系表示不自然<br />对插入删除擦做限制多，引用程序的编写比较复杂<br />查询子女结点必须通过双亲结点<br />由结构严密，层次命令趋于程序化</p><h3 id="5网状模型"><a class="anchor" href="#5网状模型">#</a> 5. 网状模型</h3><h3 id="6关系模型"><a class="anchor" href="#6关系模型">#</a> 6. 关系模型</h3>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch3_数据链路层</title>
      <link href="/2022/10/16/Ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2022/10/16/Ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a class="anchor" href="#数据链路层">#</a> 数据链路层</h1><h2 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h2><ul><li><strong>结点</strong>：主机、路由器。</li><li><strong>链路</strong>：网络中两个结点之间的<strong>物理通道</strong>，链路的传输介质主要有 - 双绞线、光纤 and 微波。分为 有线链路、无线链路。</li><li><strong>数据链路</strong>：网络中两个结点之间的<strong>逻辑通道</strong>，把实现控制数据 传输协议的硬件和软件加到链路上 就构成数据链路。</li><li><strong>桢</strong>：链路层的协议数据单元，封装网络层数据报。</li><li><strong>数据链路层</strong>：负责通过一条链路 从一个结点向另一个物理链路直接相连的相邻结点 传送数据报。</li></ul><p>功能概述：在物理层提供服务的基础上向 网络层提供服务，其最基本的服务是 将源自网络层来的数据可靠地传输到相邻结点的目标机网络层。<br />主要作用：<strong>加强物理层传输原始比特流</strong>的功能。将物理层提供的可能出错的物理连接改造成为 逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><pre><code>**功能一**：为网络层提供服务。有确认无连接服务，无确认无连接服务，有确认面向连接服务。！有连接一定有确认！**功能二**：链路管理，即连接的建立、维持、释放。(用于面向连接服务)**功能三**：组帧。**功能四**：流量控制。**功能五**：差错控制(帧错/位错)。</code></pre><h1 id="封装成帧透明传输"><a class="anchor" href="#封装成帧透明传输">#</a> 封装成帧 &amp; 透明传输</h1><h2 id="封装成帧"><a class="anchor" href="#封装成帧">#</a> 封装成帧</h2><ul><li><strong>封装成帧</strong>：在一段数据的前后部分添加首部和尾部，构成一个帧。<br />接收端在收到物理层 上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<br />首部和尾部包含许多的控制信息，重要作用 -- 帧定界 (确定帧的界限)</li><li><strong>帧同步</strong>：接收方应当能从接收到的 二进制比特流中区分出 帧的起始和终止。</li></ul><p><strong>组帧</strong>四种方法：字符计数法、字符 (节) 填充法、零比特填充法、违法编码法。</p><h2 id="透明传输"><a class="anchor" href="#透明传输">#</a> 透明传输</h2><p>是指不管所传的数据是什么样的比特组合，都应当能在链路上传送。so，链路层就 &quot;看不见&quot; 有什么妨碍数据传输的东西。<br />当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使接收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输透明的。</p><h3 id="字符计数法"><a class="anchor" href="#字符计数法">#</a> 字符计数法</h3><p><a href="https://imgse.com/i/zDZ4qf"><img data-src="https://s1.ax1x.com/2022/12/02/zDZ4qf.jpg" alt="zDZ4qf.jpg" /></a></p><h3 id="字符节填充法"><a class="anchor" href="#字符节填充法">#</a> 字符 (节) 填充法</h3><p>(字符填充的首位定界法)<br /> 方法是：发送端的数据链路层在数据中出现控制字符 “SOH” 或 “EOT” 的前面插入一个转义字符”ESC”。而在接收端的数据链路层在将数据送往网络层之前删除这个插入的转义字符。我们把这种方法叫做字节填充法。当然如果转义字符”ESC“也出现在数据当中，那么解决的方法仍然是在转义字符的前面插入一个转义字符，所以，当接受到连续的两个转义字符的时候，就去删除其中前面的一个<br /><a href="https://imgse.com/i/zDZIZ8"><img data-src="https://s1.ax1x.com/2022/12/02/zDZIZ8.jpg" alt="zDZIZ8.jpg" /></a></p><h3 id="零比特填充法"><a class="anchor" href="#零比特填充法">#</a> 零比特填充法</h3><p>由于使用 01111110（6 个 1）来标志一帧的开始和结束，故发送方只要在数据中遇到 5 个连续的 “1” 时，自动在其后插入一个 “0”；接收方每收到 5 个连续的 “1” 时，自动删除后面紧跟的 “0”，以恢复原信息。<br /><strong>保证了透明传输：在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</strong><br /><a href="https://imgse.com/i/zDZhsP"><img data-src="https://s1.ax1x.com/2022/12/02/zDZhsP.jpg" alt="zDZhsP.jpg" /></a></p><h3 id="违法编码发"><a class="anchor" href="#违法编码发">#</a> 违法编码发</h3><p>曼彻斯特编码：</p><p>计算机传输数据时，用「电流」的高低来标识数据，「一高一低」的电流表示 1 ，「一低一高」的电流表示 0 。</p><p>违规编码法利用违规的电流来表示帧界定符，比如，用两个连续的高电流表示帧的开始，两个连续的底电流表示帧的结束<br />局域网中 IEEE 802 就采用了这种方法。<br /><a href="https://imgse.com/i/zDZfMt"><img data-src="https://s1.ax1x.com/2022/12/02/zDZfMt.jpg" alt="zDZfMt.jpg" /></a></p><p>差分曼彻斯特编码：</p><h1 id="差错控制检错编码"><a class="anchor" href="#差错控制检错编码">#</a> 差错控制 (检错编码)</h1><p>传输中的差错都是由于噪声引起的。</p><ol><li>全局性：由于线路本身的电气特性所产生的<strong>随机噪声</strong> (热噪声)，是信道固有的，随即存在的。<br />解决方法：提高信噪比来减少 or 避免干扰。(对传感器下手)</li><li>局部性：外界特性的短暂原因所造成的<strong>冲击噪声</strong>，是产生差错的主要原因。<br />解决方法：通常利用编码技术来解决。</li></ol><p><a href="https://imgse.com/i/zDeFzR"><img data-src="https://s1.ax1x.com/2022/12/02/zDeFzR.jpg" alt="zDeFzR.jpg" /></a><br /> 链路层为网络层提供服务：无确认无连接服务、有确认无连接服务、有确认面向连接服务。</p><h2 id="检错编码"><a class="anchor" href="#检错编码">#</a> 检错编码</h2><h3 id="奇偶校验"><a class="anchor" href="#奇偶校验">#</a> 奇偶校验</h3><blockquote><p>奇校验：这串序列 1 的个数如果为偶数则在前面加个 1，使 1 的个数变成奇数，否则加 0。</p></blockquote><blockquote><p>偶校验：这串序列 1 的个数如果为奇数则在前面加个 1，使 1 的个数变成偶数，否则加 0。</p></blockquote><h3 id="循环冗余码crc"><a class="anchor" href="#循环冗余码crc">#</a> 循环冗余码 CRC</h3><h2 id="纠错编码-海明码"><a class="anchor" href="#纠错编码-海明码">#</a> 纠错编码 海明码！</h2><p>海明码学习前提<br />要点：</p><ol><li>不要用异或套用公式！！！题目随便变几个变死你！</li><li>看完这篇博客不要看别的博客！！！！别的人瞎写的坑死你</li></ol><p>学习海明码之前，我们要约定 3 个原则：</p><ol><li>海明码只能检测出 2 位错，纠 1 位错。</li><li>默认进行偶校验 (除说明用奇校验)</li><li>海明码是一串由 0 和 1 组成的序列 (除 01 外没有其他的值，记住了！这是重点)<br /> 如果下面有任何无法理解的问题，反复看上面三个原则，下面再也不赘述。</li></ol><h3 id="前提奇偶校验"><a class="anchor" href="#前提奇偶校验">#</a> 前提：奇偶校验</h3><blockquote><p>奇校验：这串序列 1 的个数如果为偶数则在前面加个 1，使 1 的个数变成奇数，否则加 0。</p></blockquote><blockquote><p>偶校验：这串序列 1 的个数如果为奇数则在前面加个 1，使 1 的个数变成偶数，否则加 0。</p></blockquote><p>例子：1111 奇校验就是 11111 偶校验就是 01111<br />1110 奇校验就是 01110 偶校验就是 11110</p><p><strong>特性是检测一位错，无法纠错。</strong></p><h3 id="概述海明码的构成"><a class="anchor" href="#概述海明码的构成">#</a> 概述：海明码的构成</h3><p>例如如下序列：<br />D = 1100<br /> 我们想要让其变成海明码只需如下操作</p><ol><li>算出校验位数 k#<br />正常情况下我们需要如下此操作：</li></ol><p>2^k &gt;= k + 数据位数 + 1</p><p>这里等于 3</p><ol start="2"><li>确定校验位在海明码中的位置#<br />这里按 2^k 次幂留出来，就像 1，2，4，8，16，32。（如果问有 5 位等其他烦人的数据位怎么办后面我会说，先按 4 位数做）</li></ol><table><thead><tr><th>H7</th><th>H6</th><th>H5</th><th>H4</th><th>H3</th><th>H2</th><th>H1</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td></td><td>0</td><td></td><td></td></tr></tbody></table><ol start="3"><li>分组（重点，很多人蒙圈就在此）#<br />我们需要确认 H1,H2,H4 这三个校验位都来校验哪些位置。<br />我们按这个规则进行分配。</li></ol><p>将 1,2,4（海明码下标为 1,2,4）#<br />的二进制码写出来，并且最高位补到 3 位 (前面算的 K 数)<br /> 如下所示：</p><table><thead><tr><th>1</th><th>2</th><th>4</th></tr></thead><tbody><tr><td>001</td><td>010</td><td>100</td></tr></tbody></table><p><strong>然后我们将 0 替换为 /*，作为通配表</strong></p><table><thead><tr><th>1</th><th>2</th><th>4</th></tr></thead><tbody><tr><td>**1</td><td>·1·</td><td>1··</td></tr></tbody></table><p><strong>我们将 1 到 7 的二进制序列，列出来如下表</strong></p><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th></tr></thead><tbody><tr><td>111</td><td>110</td><td>101</td><td>100</td><td>011</td><td>010</td><td>001</td></tr></tbody></table><p><strong>！！！重点！！！！#</strong><br />我们将 7-&gt;1 依次与上面的通配表进行匹配</p><table><thead><tr><th>1</th><th>2</th><th>4</th></tr></thead><tbody><tr><td>**1</td><td>·1·</td><td>1··</td></tr><tr><td>001(1)</td><td>010(2)</td><td>100(4)</td></tr><tr><td>011(3)</td><td>011(3)</td><td>101(5)</td></tr><tr><td>101(5)</td><td>110(6)</td><td>110(6)</td></tr><tr><td>111(7)</td><td>111(7)</td><td>111(7)</td></tr></tbody></table><p>因此我们可以确定<br /> H1 负责 1 3 5 7 位数的校验<br /> H2 负责 2 3 6 7 位数的校验<br /> H4 负责 4 5 6 7 位数的校验</p><ol start="4"><li>求出校验位是 0 还是 1#</li></ol><p>因为上面我们得出以下结论：<br />H1 负责 1 3 5 7 位数的校验<br /> H2 负责 2 3 6 7 位数的校验<br /> H4 负责 4 5 6 7 位数的校验</p><p><strong>偶校验</strong><br /> H3,H5,H7 1 的个数为奇数 因此 H1=1<br />H3,H6,H7 1 的个数为偶数 因此 H2=0<br />H5,H6,H7 1 的个数为偶数 因此 H4=0</p><table><thead><tr><th>H7</th><th>H6</th><th>H5</th><th>H4</th><th>H3</th><th>H2</th><th>H1</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><ol start="5"><li>查错#<br />查错比较简单，如果以下三组<br />既<br /> H1,H3,H5,H7<br /> 或者<br /> H2,H3,H6,H7<br /> 或者<br /> H4,H5,H6,H7<br /> 偶校验出错，则出错。</li></ol><p>比方说 如果 H1,H3,H5,H7 由 1100 变成了 1110 （1 的个数为偶数）就是出错了</p><p>这里该不赘述<br /> 6. 纠错#<br />首先我们先理解以下为什么海明码能纠错。<br />首先我们先画个圆。然后按如下形式做交叉<br /><a href="https://imgse.com/i/zZAiND"><img data-src="https://s1.ax1x.com/2022/11/16/zZAiND.jpg" alt="zZAiND.jpg" /></a><br /> 如果这个位置出错了，那么一定是 1 3 7 5 这四个位置中的一个位置出错 (如果俩位出错则无法纠错，这个点一定要记住)<br /> 如果此时其他的俩个组 即：2，3，6，7 和 4，5，6，7 偶校验都通过了的话。<br />也就证明只可能是 1 出错<br />所以我们可以将 1 的位数 做修改。如果是 0 变为 1，如果是 1 变为。来达到纠错的目的。</p><p>但是如果 2，3，5，7 这个位置也出错了，4，5，6，7 这个位置没有出错。<br />我们很容易就推导出，是 3 这个位置出错了。<br />我们就可以修改 3 的值，如果是 0 变为 1 或者如果是 1 变为 0.</p><p>在此时我们会发现一个巧妙的规则！<br />当我们把 1，3，5，7 设为 P1,<br />2,3,6,7 设为 P2<br />4,5,6,7 设为 P3 时</p><p>当如果哪组校验失败就为 1<br /><a href="https://imgse.com/i/zZAF4e"><img data-src="https://s1.ax1x.com/2022/11/16/zZAF4e.jpg" alt="zZAF4e.jpg" /></a></p><p>转载：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29kb2ZvcmFuZ2UvcC8xMjAwMzY3Ni5odG1s">https://www.cnblogs.com/godoforange/p/12003676.html</span></p><h1 id="流量控制"><a class="anchor" href="#流量控制">#</a> 流量控制</h1><p>数据链路层的流量控制是<strong>点对点</strong>的、传输层的流量控制是<strong>端到端</strong>。<br /><strong>数据链路层</strong>流量控制手段：接收方收不下就不回复确认。<br /><strong>传输层</strong>流量控制手段：接收端给发送端一个窗口公告。</p><h2 id="停止等待协议"><a class="anchor" href="#停止等待协议">#</a> 停止等待协议</h2><p>信道利用率太低！</p><h2 id="后退n帧协议gbn"><a class="anchor" href="#后退n帧协议gbn">#</a> 后退 N 帧协议 (GBN)</h2><h2 id="选择重传协议sr"><a class="anchor" href="#选择重传协议sr">#</a> 选择重传协议 (SR)</h2><h1 id="信道划分介质访问控制"><a class="anchor" href="#信道划分介质访问控制">#</a> 信道划分介质访问控制</h1><ul><li>6</li><li>7</li></ul><h1 id="传输数据适用的两种链路"><a class="anchor" href="#传输数据适用的两种链路">#</a> 传输数据适用的两种链路</h1><h2 id="点对点链路"><a class="anchor" href="#点对点链路">#</a> 点对点链路</h2><p>两个相邻节点通过一个链路相连，没有第三者。<br />Application: PPP 协议、常用于广域网。</p><h2 id="广播式链路"><a class="anchor" href="#广播式链路">#</a> 广播式链路</h2><p>所有主机共享通信介质<br /> Application: 早期的总线以太网、无线局域网，常用于<strong>局域网</strong>。<br />典型拓扑结构：总线型、星型 (逻辑总线型)</p><h1 id="介质访问控制"><a class="anchor" href="#介质访问控制">#</a> 介质访问控制</h1><p><a href="https://imgse.com/i/zra4Df"><img data-src="https://s1.ax1x.com/2022/12/03/zra4Df.jpg" alt="zra4Df.jpg" /></a><br /> 采取一定的措施，使得两对节点之间的通信不会发生干扰的情况</p><h2 id="静态信道划分-信道划分介质访问控制"><a class="anchor" href="#静态信道划分-信道划分介质访问控制">#</a> 静态信道划分 - 信道划分介质访问控制</h2><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备<br /><a href="https://imgse.com/i/zrMJtf"><img data-src="https://s1.ax1x.com/2022/12/03/zrMJtf.jpg" alt="zrMJtf.jpg" /></a></p><h3 id="频分多路复用-fdm"><a class="anchor" href="#频分多路复用-fdm">#</a> 频分多路复用 FDM</h3><p>频分复用的所有用户在同样的时间占用不同的带宽 (频率带宽) 资源。</p><p><a href="https://imgse.com/i/zrM37t"><img data-src="https://s1.ax1x.com/2022/12/03/zrM37t.jpg" alt="zrM37t.jpg" /></a></p><h3 id="时分多路复用-tdm"><a class="anchor" href="#时分多路复用-tdm">#</a> 时分多路复用 TDM</h3><p>时分复用帧 (TDM) 是在物理层传送的比特流所划分的帧、标志一个周期。<br />每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙、所有用户轮流占用信道。<br />g<br /><a href="https://imgse.com/i/zrMGAP"><img data-src="https://s1.ax1x.com/2022/12/03/zrMGAP.jpg" alt="zrMGAP.jpg" /></a></p><blockquote><p>改进的时分复用 -- 统计时分复用 STDM**（Statistical Time Division Multiplexing）</p></blockquote><p>STDM 帧不是固定分配时隙、而是按需动态分配时隙</p><p><a href="https://imgse.com/i/zrM10I"><img data-src="https://s1.ax1x.com/2022/12/03/zrM10I.jpg" alt="zrM10I.jpg" /></a></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUVFNDExMzdIUy8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT04YjI3MWNiYTc1NjFmNThlZGY0MTA2ZGIwZGYxY2M1ZA==">https://www.bilibili.com/video/BV1EE41137HS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8b271cba7561f58edf4106db0df1cc5d</span></p><h3 id="波分多路复用-wdm"><a class="anchor" href="#波分多路复用-wdm">#</a> 波分多路复用 WDM</h3><p>(Wavelength Division Multiplexer)<br /> 光的频分多路复用<br /><a href="https://imgse.com/i/zrMlnA"><img data-src="https://s1.ax1x.com/2022/12/03/zrMlnA.jpg" alt="zrMlnA.jpg" /></a></p><h3 id="码分多路复用-cdm"><a class="anchor" href="#码分多路复用-cdm">#</a> 码分多路复用 CDM</h3><p>2G 网络就是 CDMA 技术<br />可以让不同的用户在同样时间使用同样频率进行通信。由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会干扰。</p><p>CDMA 中、每一个比特时间在划分为 m 个短的间隔、称为码片 (chip).m 通常为 64 or 128</p><p>若叠加为（A+B+C）,A 收到并做内积得（A+B+C）*A, 由于 A 与 B 和 C 正交，所以（A+B+C）<em>A=A</em>A<br /><a href="https://imgse.com/i/zrU4k4"><img data-src="https://s1.ax1x.com/2022/12/03/zrU4k4.jpg" alt="zrU4k4.jpg" /></a><br /><a href="https://imgse.com/i/zrUW0U"><img data-src="https://s1.ax1x.com/2022/12/03/zrUW0U.jpg" alt="zrUW0U.jpg" /></a><br /><a href="https://imgse.com/i/zra91I"><img data-src="https://s1.ax1x.com/2022/12/03/zra91I.jpg" alt="zra91I.jpg" /></a><br /><a href="https://imgse.com/i/zrUf7F"><img data-src="https://s1.ax1x.com/2022/12/03/zrUf7F.jpg" alt="zrUf7F.jpg" /></a></p><h2 id="动态分配信道"><a class="anchor" href="#动态分配信道">#</a> 动态分配信道</h2><ol><li>轮询访问介质访问控制 令牌传递协议</li><li>随机访问介质访问控制 -&gt;4</li></ol><h3 id="aloha协议"><a class="anchor" href="#aloha协议">#</a> ALOHA 协议</h3><h3 id="csma协议"><a class="anchor" href="#csma协议">#</a> CSMA 协议</h3><ol><li>1 - 坚持 CSMA</li><li>非坚持 CSMA</li><li>p - 坚持 CSMA</li></ol><p><a href="https://imgse.com/i/zrsqTP"><img data-src="https://s1.ax1x.com/2022/12/03/zrsqTP.jpg" alt="zrsqTP.jpg" /></a></p><h3 id="csmacd协议"><a class="anchor" href="#csmacd协议">#</a> CSMA/CD 协议</h3><h3 id="csmaca协议"><a class="anchor" href="#csmaca协议">#</a> CSMA/CA 协议</h3>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch2_物理层</title>
      <link href="/2022/10/16/Ch2-%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2022/10/16/Ch2-%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h1><p>物理层考虑的是怎样才能在 连接各种计算机の传输媒体上 传输数据比特流。</p><p>物理层为数据链路层屏蔽了各种传输媒体の差异、使数据链路层只需考虑 如何完成本层の协议 &amp; 服务，而不必考虑网络具体的传输媒体是什么。</p><p><strong>物理层协议の主要任务：</strong></p><ol><li><p>机械特性：<br />指明接口所用接线器的<strong>形状</strong>和<strong>尺寸</strong>，<strong>引脚数目</strong>和<strong>排列</strong>、<strong>固定</strong>和<strong>锁定</strong>装置。</p></li><li><p>电器特性：<br />指明在接口电缆の各条线上出现の<strong>电压的范围</strong>。</p></li><li><p>功能特性：<br />指明某条线上 出现的 某一电平 的<strong>电压 表示何种意义</strong>。</p></li><li><p>过程特性：<br />指明对于不同功能的 各种可能<strong>事件 的出现顺序</strong>。</p></li></ol><h1 id="の传输媒体"><a class="anchor" href="#の传输媒体">#</a> の传输媒体</h1><h2 id="导引型传输媒体"><a class="anchor" href="#导引型传输媒体">#</a> 导引型传输媒体</h2><h3 id="同轴电缆"><a class="anchor" href="#同轴电缆">#</a> 同轴电缆</h3><p>贵、布线不灵活 不方便</p><ol><li>基带同轴电缆</li><li>宽带同轴电缆</li></ol><h3 id="双绞线"><a class="anchor" href="#双绞线">#</a> 双绞线</h3><p><strong>绞合の作用：</strong></p><blockquote><p>抵御部分来自外界的电磁波干扰<br />减少相邻导线的电磁波干扰</p></blockquote><h3 id="光纤"><a class="anchor" href="#光纤">#</a> 光纤</h3><p>优点：</p><blockquote><p>通信容量大 (25000~30000GHz 的宽带)<br /> 传输损耗小、远距离传输时更加经济<br />抗<strong>雷电</strong>和<strong>电磁干扰</strong> 性能好。在大电流脉冲干扰的环境尤为重要<br />无串音干扰、保密性好、不易被窃听<br />体积小、重量轻</p></blockquote><p>缺点：</p><blockquote><p>割接需要专用设备<br />光电接口价格较贵</p></blockquote><ol><li>多模光纤：50 微米、62.5 微米</li><li>只适合<strong>近距离传输</strong> (建筑物内)</li><li>单模光纤：9 微米</li><li>适合长距离传输且衰减小、制造成本高、对光源要求高</li></ol><ul><li>光在纤芯中传输の方式是<strong>不断地全反射</strong></li></ul><p><strong>当光从高折射率的媒体射向低折射率的媒体时，其 折射角 &gt; 入射角；</strong></p><p><strong>因此、如果入射角足够大，就会出现全反射，即光碰到包层时 就会反射回纤芯</strong></p><h3 id="电力线"><a class="anchor" href="#电力线">#</a> 电力线</h3><p><a href="https://imgse.com/i/zcuFDH"><img data-src="https://s1.ax1x.com/2022/12/06/zcuFDH.jpg" alt="zcuFDH.jpg" /></a></p><h2 id="非导引型传输媒体"><a class="anchor" href="#非导引型传输媒体">#</a> 非导引型传输媒体</h2><h3 id="无线电波"><a class="anchor" href="#无线电波">#</a> 无线电波</h3><p><a href="https://imgse.com/i/zcukbd"><img data-src="https://s1.ax1x.com/2022/12/06/zcukbd.jpg" alt="zcukbd.jpg" /></a></p><h3 id="微波"><a class="anchor" href="#微波">#</a> 微波</h3><ol><li>地面微波接力通信</li><li>卫星通信</li></ol><h3 id="红外线"><a class="anchor" href="#红外线">#</a> 红外线</h3><p>点对点传输 直线传输</p><h3 id="可见光"><a class="anchor" href="#可见光">#</a> 可见光</h3><p>LiFi</p><h1 id="传输方式"><a class="anchor" href="#传输方式">#</a> 传输方式</h1><h2 id="串行传输"><a class="anchor" href="#串行传输">#</a> 串行传输</h2><h2 id="并行传输"><a class="anchor" href="#并行传输">#</a> 并行传输</h2><p><a href="https://imgse.com/i/zcK5lT"><img data-src="https://s1.ax1x.com/2022/12/06/zcK5lT.jpg" alt="zcK5lT.jpg" /></a></p><h2 id="同步传输"><a class="anchor" href="#同步传输">#</a> 同步传输</h2><h2 id="异步传输"><a class="anchor" href="#异步传输">#</a> 异步传输</h2><p><a href="https://imgse.com/i/zcK4pV"><img data-src="https://s1.ax1x.com/2022/12/06/zcK4pV.jpg" alt="zcK4pV.jpg" /></a></p><h2 id="单向通信单工"><a class="anchor" href="#单向通信单工">#</a> 单向通信 (单工)</h2><h2 id="双向交替通信半双工"><a class="anchor" href="#双向交替通信半双工">#</a> 双向交替通信 (半双工)</h2><p>对讲机</p><h2 id="双向同时通信全双工"><a class="anchor" href="#双向同时通信全双工">#</a> 双向同时通信 (全双工)</h2><p><a href="https://imgse.com/i/zcKff0"><img data-src="https://s1.ax1x.com/2022/12/06/zcKff0.jpg" alt="zcKff0.jpg" /></a></p><h1 id="编码与调制"><a class="anchor" href="#编码与调制">#</a> 编码与调制</h1><p>码元：在使用时间域的波形 表示数字信号时、代表<strong>不同离散数值</strong>的基本波形。<br /><a href="https://imgse.com/i/zcM2uD"><img data-src="https://s1.ax1x.com/2022/12/06/zcM2uD.jpg" alt="zcM2uD.jpg" /></a></p><h2 id="常用编码"><a class="anchor" href="#常用编码">#</a> 常用编码</h2><h3 id="不归零编码"><a class="anchor" href="#不归零编码">#</a> 不归零编码</h3><p><a href="https://imgse.com/i/zcMcjO"><img data-src="https://s1.ax1x.com/2022/12/06/zcMcjO.jpg" alt="zcMcjO.jpg" /></a></p><h3 id="归零编码"><a class="anchor" href="#归零编码">#</a> 归零编码</h3><p><a href="https://imgse.com/i/zcM6gK"><img data-src="https://s1.ax1x.com/2022/12/06/zcM6gK.jpg" alt="zcM6gK.jpg" /></a></p><h3 id="曼彻斯特编码"><a class="anchor" href="#曼彻斯特编码">#</a> 曼彻斯特编码</h3><p>码元中间时刻跳变 表示：时钟、数据</p><h3 id="差分曼彻斯特编码"><a class="anchor" href="#差分曼彻斯特编码">#</a> 差分曼彻斯特编码</h3><p>码元中间时刻跳变 表示：时钟<br />码元开始处电平是否发生变化：数据<br /><a href="https://imgse.com/i/zcMy36"><img data-src="https://s1.ax1x.com/2022/12/06/zcMy36.jpg" alt="zcMy36.jpg" /></a></p><p><a href="https://imgse.com/i/zcQEVJ"><img data-src="https://s1.ax1x.com/2022/12/06/zcQEVJ.md.jpg" alt="zcQEVJ.md.jpg" /></a></p><h2 id="基本调制方法"><a class="anchor" href="#基本调制方法">#</a> 基本调制方法</h2><p><a href="https://imgse.com/i/zcl51P"><img data-src="https://s1.ax1x.com/2022/12/06/zcl51P.jpg" alt="zcl51P.jpg" /></a><br /><a href="https://imgse.com/i/zcl4pt"><img data-src="https://s1.ax1x.com/2022/12/06/zcl4pt.jpg" alt="zcl4pt.jpg" /></a><br /><a href="https://imgse.com/i/zclffI"><img data-src="https://s1.ax1x.com/2022/12/06/zclffI.jpg" alt="zclffI.jpg" /></a></p><h3 id="混合调制"><a class="anchor" href="#混合调制">#</a> 混合调制</h3><p><strong>--- 正交振幅调制 QAM</strong></p><p><a href="https://imgse.com/i/zclWtA"><img data-src="https://s1.ax1x.com/2022/12/06/zclWtA.jpg" alt="zclWtA.jpg" /></a></p><h2 id="信道的极限容量"><a class="anchor" href="#信道的极限容量">#</a> 信道的极限容量</h2><p><a href="https://imgse.com/i/zclRkd"><img data-src="https://s1.ax1x.com/2022/12/06/zclRkd.jpg" alt="zclRkd.jpg" /></a></p><h3 id="奈氏准则"><a class="anchor" href="#奈氏准则">#</a> 奈氏准则</h3><p>在假定理想条件下、为了<strong>避免码间串扰、码元传输速率是有上限的</strong>。</p><blockquote><p>理想低通信道の最高码元传输速率 = 2W Baud = 2W<br /> 理想带通信道の最高码元传输速率 = W Baud = W</p></blockquote><p><strong>W 信道带宽</strong><br /><a href="https://imgse.com/i/zc3nGn"><img data-src="https://s1.ax1x.com/2022/12/06/zc3nGn.jpg" alt="zc3nGn.jpg" /></a></p><h3 id="香农公式"><a class="anchor" href="#香农公式">#</a> 香农公式</h3><p><a href="https://imgse.com/i/zc3u2q"><img data-src="https://s1.ax1x.com/2022/12/06/zc3u2q.jpg" alt="zc3u2q.jpg" /></a><br /><a href="https://imgse.com/i/zc3Kx0"><img data-src="https://s1.ax1x.com/2022/12/06/zc3Kx0.jpg" alt="zc3Kx0.jpg" /></a></p><h3 id="例题"><a class="anchor" href="#例题">#</a> 例题：</h3><p><a href="https://imgse.com/i/zc3EVg"><img data-src="https://s1.ax1x.com/2022/12/06/zc3EVg.jpg" alt="zc3EVg.jpg" /></a><br /><a href="https://imgse.com/i/zc3VaQ"><img data-src="https://s1.ax1x.com/2022/12/06/zc3VaQ.jpg" alt="zc3VaQ.jpg" /></a><br /><a href="https://imgse.com/i/zc3Z5j"><img data-src="https://s1.ax1x.com/2022/12/06/zc3Z5j.jpg" alt="zc3Z5j.jpg" /></a><br /><a href="https://imgse.com/i/zc3kqS"><img data-src="https://s1.ax1x.com/2022/12/06/zc3kqS.jpg" alt="zc3kqS.jpg" /></a><br /><a href="https://imgse.com/i/zc3Fr8"><img data-src="https://s1.ax1x.com/2022/12/06/zc3Fr8.jpg" alt="zc3Fr8.jpg" /></a><br /><a href="https://imgse.com/i/zc3mPs"><img data-src="https://s1.ax1x.com/2022/12/06/zc3mPs.jpg" alt="zc3mPs.jpg" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch1_计网体系结构</title>
      <link href="/2022/10/16/Ch1-%E8%AE%A1%E7%BD%91%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2022/10/16/Ch1-%E8%AE%A1%E7%BD%91%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="计网体系结构"><a class="anchor" href="#计网体系结构">#</a> 计网体系结构</h1><h2 id="概念"><a class="anchor" href="#概念">#</a> 概念</h2><ol><li><p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的软件实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p></li><li><p>计算机网络是互连的、自治的计算机集合。</p><ul><li>互连：通过通信链路互联互通。</li><li>自治：无主从关系。</li></ul></li></ol><h2 id="功能"><a class="anchor" href="#功能">#</a> 功能</h2><ol><li>数据通信</li><li>资源共享  （可共享硬件、软件、数据 ）</li><li>分布式处理  （多台计算机各自承担同一工作任务的不同部分 Hadoop...）<ul><li>可靠性</li><li>负载均衡</li></ul></li></ol><h2 id="因特网发展阶段"><a class="anchor" href="#因特网发展阶段">#</a> 因特网发展阶段</h2><ol><li><p>ARPAnet 阿帕网 (无线分组交换网 &amp; 卫星通信网) -&gt; internet (1983 阿帕网接受 TCP/IP)(互联网) -&gt; Internet (因特网)</p></li><li><p>三级结构：</p></li></ol><p>1985 年起 USA 国家科学基金会 NSF 围绕 6 个大型计算机中心建设计算机网络，即国家科学基金网 NSFNET<br /> 主干网：<br />- 地区网：<br />- 校园网<br /> - 校园网<br /> - 地区网：<br />- 企业网<br /> 3. 多层次 ISP 结构：<br />ISP：Internet service provider 若中国电信、<br />分为 主干 ISP、地区 ISP、本地 ISP・・</p><h1 id="组成分类"><a class="anchor" href="#组成分类">#</a> 组成 &amp; 分类</h1><p><a href="https://imgse.com/i/xBKch6"><img data-src="https://s1.ax1x.com/2022/10/16/xBKch6.png" alt="" /></a><a href="https://imgse.com/i/xBK29K"><img data-src="https://s1.ax1x.com/2022/10/16/xBK29K.png" alt="" /></a></p><p><a href="https://imgse.com/i/xBJ5kQ"><img data-src="https://s1.ax1x.com/2022/10/16/xBJ5kQ.md.png" alt="xBJ5kQ.md.png" /></a></p><h2 id="性能指标"><a class="anchor" href="#性能指标">#</a> 性能指标</h2><ul><li><strong>速率</strong>：即数据率 or 数据传输率 or 比特率。<br />连接在计算机网络上的<em>主机</em>在数字信道上传送数据<em>位数的速率</em>。</li><li><strong>带宽</strong>：表示网络的通信线路传送数据的能力，通常指单位时间内从网络中的某一点到另外一点所能通过的 “最高数据率”。单位 “比特每秒”<br /> 原指某个信号具有的频带宽度，最高频率与最低频率只差，单位是赫兹（Hz）</li><li><strong>吞吐量</strong>单位时间内通过某个网络 (or 信道、接口) 的数据量。</li><li><strong>时延</strong>：指数据 (报文 / 分组 / 比特流) 从网络 (or 链路) 的一端传送到另一端所需的时间。也叫延迟 or 迟延。单位 S。</li><li><strong>时延带宽积</strong>：传播时延 x 带宽 (某段链路现在有多少比特)</li><li><strong>往返时间 RTT</strong>：包括往返传播时延 (传播时延 * 2) + 末端处理时间</li><li><strong>利用率</strong>：信道利用率 网络利用率<br /><a href="https://imgse.com/i/xBaF8H"><img data-src="https://s1.ax1x.com/2022/10/16/xBaF8H.png" alt="速率.png" /></a><br /><a href="https://imgse.com/i/xBaVKI"><img data-src="https://s1.ax1x.com/2022/10/16/xBaVKI.png" alt="带宽.png" /></a><br /><a href="https://imgse.com/i/xBaAxA"><img data-src="https://s1.ax1x.com/2022/10/16/xBaAxA.png" alt="吞吐量.png" /></a><br /><a href="https://imgse.com/i/xBak2d"><img data-src="https://s1.ax1x.com/2022/10/16/xBak2d.png" alt="时延.png" /></a><br /><a href="https://imgse.com/i/xBaJrq"><img data-src="https://s1.ax1x.com/2022/10/16/xBaJrq.png" alt="利用率.png" /></a></li></ul><h1 id="专业术语"><a class="anchor" href="#专业术语">#</a> 专业术语</h1><p><a href="https://imgse.com/i/zsWJzV"><img data-src="https://s1.ax1x.com/2022/12/04/zsWJzV.jpg" alt="zsWJzV.jpg" /></a></p><h2 id="实体"><a class="anchor" href="#实体">#</a> 实体</h2><p>任何可发送 or 接受信息的<strong>硬件</strong> or<strong> 软件进程</strong>。</p><h2 id="对等实体"><a class="anchor" href="#对等实体">#</a> 对等实体</h2><p>收发双方相同层次中的实体<br /><a href="https://imgse.com/i/zsRa4I"><img data-src="https://s1.ax1x.com/2022/12/04/zsRa4I.jpg" alt="zsRa4I.jpg" /></a></p><h2 id="协议"><a class="anchor" href="#协议">#</a> 协议</h2><p>控制两个对等实体进行逻辑通信的规则的集合<br />三要素 ： 语法、语义、同步</p><ol><li>语法 ：定义所交换信息的格式<br /><a href="https://imgse.com/i/zsWQaj"><img data-src="https://s1.ax1x.com/2022/12/04/zsWQaj.jpg" alt="zsWQaj.jpg" /></a></li><li>语义 ：定义收发双方所要完成的操作<br /><a href="https://imgse.com/i/zsWuqg"><img data-src="https://s1.ax1x.com/2022/12/04/zsWuqg.jpg" alt="zsWuqg.jpg" /></a></li><li>同步 ：定义收发双方的时序关系<br /><a href="https://imgse.com/i/zsWMZQ"><img data-src="https://s1.ax1x.com/2022/12/04/zsWMZQ.jpg" alt="zsWMZQ.jpg" /></a></li></ol><h2 id="服务"><a class="anchor" href="#服务">#</a> 服务</h2><ul><li>在协议控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务</li><li>要实现本层协议，还需要下面一层所提供的服务</li></ul><blockquote><p><strong>协议</strong>是 &quot;水平的 horizontal&quot;,<strong> 服务</strong>是 &quot;垂直的 vertical&quot;</p></blockquote><ul><li>实体看得见相邻下层所提供的服务、但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的是 “透明” 的。</li></ul><h3 id="服务访问点"><a class="anchor" href="#服务访问点">#</a> 服务访问点</h3><p>在同一系统中<strong>相邻两层的实体交换信息的逻辑接口</strong>，用于区分不同的服务类型</p><ol><li>数据链路层の服务访问点为帧の &quot;类型&quot; 字段。</li><li>网络层の服务访问点为 IP 数据报首部中の “协议字段”</li><li>运输层の服务访问点为 “端口号”<br /><a href="https://imgse.com/i/zsfr7Q"><img data-src="https://s1.ax1x.com/2022/12/04/zsfr7Q.jpg" alt="zsfr7Q.jpg" /></a></li></ol><h3 id="服务原语"><a class="anchor" href="#服务原语">#</a> 服务原语</h3><p>上层使用下层所提供の服务必须通过与下一层交换一些命令，这些命令称为服务原语<br /><a href="https://imgse.com/i/zs4sWn"><img data-src="https://s1.ax1x.com/2022/12/04/zs4sWn.jpg" alt="zs4sWn.jpg" /></a></p><h3 id="协议数据单元pdu"><a class="anchor" href="#协议数据单元pdu">#</a> 协议数据单元 PDU</h3><p>对等层次之间传送の数据包 为该层的协议数据单元 PDU<br /><a href="https://imgse.com/i/zs4Dij"><img data-src="https://s1.ax1x.com/2022/12/04/zs4Dij.jpg" alt="zs4Dij.jpg" /></a></p><h3 id="服务数据单元sdu"><a class="anchor" href="#服务数据单元sdu">#</a> 服务数据单元 SDU</h3><p>同一系统内，层与层之间交换的数据包称为服务数据单元</p><h3 id="多个sdu可以合为一个pdu-一个sdu也可划分为几个pdu"><a class="anchor" href="#多个sdu可以合为一个pdu-一个sdu也可划分为几个pdu">#</a> 多个 SDU 可以合为一个 PDU 一个 SDU 也可划分为几个 PDU</h3><p><a href="https://imgse.com/i/zs4rJs"><img data-src="https://s1.ax1x.com/2022/12/04/zs4rJs.jpg" alt="zs4rJs.jpg" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OS(一)</title>
      <link href="/2022/10/09/os(%E4%B8%80)/"/>
      <url>/2022/10/09/os(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2022/09/21/java-basic/"/>
      <url>/2022/09/21/java-basic/</url>
      
        <content type="html"><![CDATA[<p>#标题一<br />の<br /> ## 标题二</p><p>### 标题三</p><p>#### 标题四</p><p><strong>这是加粗</strong></p><p><em>这是斜体</em></p><p><s>这是横线</s></p><ul><li><p>无序列表</p></li><li><p>无序列表</p></li></ul><p>1. 有序序列 1<br />2. 有序序列 2</p><p><code>内嵌代码</code></p><pre><code>代码块</code></pre><blockquote><p>引用<br />吾生也有涯，而知也无涯</p></blockquote><p>&lt;!-- 有序列表 --&gt;</p><ol><li>凯瑟琳</li><li>海瑟薇</li><li>亚瑟。皮特<br /> &lt;!-- 无序列表 --&gt;</li></ol><ul><li>APPLE</li><li>PEACH</li><li>lemon<br />&lt;!-- 加粗 --&gt;<br /><strong> 微信：帕克</strong><br /> &lt;!-- 斜体 --&gt;<br /><em> 微信：帕克</em><br /> &lt;!-- 删除线 --&gt;<br /><s> 微信：帕克</s></li></ul><h2 id="u微信帕克u微信帕克"><a class="anchor" href="#u微信帕克u微信帕克">#</a> &lt;u&gt; 微信：帕克 &lt;/u&gt;<br /> 微信：帕克</h2><h2 id="个人博客"><a class="anchor" href="#个人博客">#</a> 个人博客：</h2><p>b 站</p><ol><li><p>上标</p><p>H<sup>2</sup>O</p></li><li><p>下标</p><p>H<sub>2</sub>O</p></li></ol><p>&lt;!-- 高亮 --&gt;<br />== 微信：帕克 ==</p><ol><li><p>未完成任务</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_0" disabled="true" /><label for="cbx_0"> 公众号：</label></li><li class="task-list-item"><input type="checkbox" id="cbx_1" disabled="true" /><label for="cbx_1"> 个人博客：</label></li></ul></li><li><p>已完成任务</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_2" checked="true" disabled="true" /><label for="cbx_2"> 知乎：</label></li><li class="task-list-item"><input type="checkbox" id="cbx_3" checked="true" disabled="true" /><label for="cbx_3"> CSDN：</label></li></ul></li><li><p>左对齐</p></li></ol><table><thead><tr><th style="text-align:left">平台</th><th style="text-align:left">链接</th></tr></thead><tbody><tr><td style="text-align:left">公众号</td><td style="text-align:left">jjjl</td></tr></tbody></table><ol start="2"><li>居中对齐</li></ol><table><thead><tr><th style="text-align:center">平台</th><th style="text-align:center">链接</th></tr></thead><tbody><tr><td style="text-align:center">公众号</td><td style="text-align:center">hh 就</td></tr></tbody></table><ol><li><p>行间公式</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_1+x_2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p></li><li><p>独立公式块</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2+y^2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p></li><li><p>链接</p></li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9jdW55dTE5NDMuc2l0ZQ==">汲汲雨</span></p><ol start="2"><li>图片</li></ol><p><img data-src="https://cdn.jsdelivr.net/gh/cunyu1943/image-hosting-for-blog/blog/image-blogzhuye.png" alt="汲汲雨" /></p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table><hr /><p>title: 第 1 周 计算<br /> date: 2020/04/12 20:46:25<br />categories:</p><ul><li>[计算机科学，Java, 零基础学 Java 语言 - 浙江大学 - 翁恺]<br />tags:</li></ul><hr /><p>:::note info<br /> 以下为个人学习笔记和习题整理<br />课程：零基础学 Java 语言 - 浙江大学 - 翁恺 @ 中国大学 MOOC<br /><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL1pKVS0xMDAxNTQxMDAx">https://www.icourse163.org/course/ZJU-1001541001</span><br />:::</p><h1 id="课堂笔记"><a class="anchor" href="#课堂笔记">#</a> 课堂笔记</h1><h2 id="读输入-字符串输出"><a class="anchor" href="#读输入-字符串输出">#</a> 读输入、字符串输出</h2><figure class="highlight java"><figcaption data-lang="java"><span>scanner</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 让 in 这个对象做读入下一行的动作，结果交给 System.out 这个对象去打印一行。</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 字符串的 + 用来连接两个字符串形成更长的字符串。</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span> <span class="token operator">+</span> <span class="token string">" world."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>tips：</p><ul><li><code>System.out.println</code>  会换行， <code>System.out.print</code>  则不会换行</li><li>出现警告： <code>Resource leak: 'in' is never closed</code> ，可以在函数的最后加入</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放</span></pre></td></tr></table></figure><h2 id="变量"><a class="anchor" href="#变量">#</a> 变量</h2><ul><li><p><strong>形式</strong>：&lt;类型名称&gt; &lt; 变量名称 &gt; = &lt; 初始值 &gt;<br /> <code>int price, amount; // 同时定义两个变量</code> <br /> <code>int price = 0; // 定义变量并赋值</code> <br /> <code>int price, amount = 100, age;</code></p></li><li><p><strong>类型名称</strong>：Java 是一种<strong>强类型语言</strong>，所有变量在使用前必须定义或声明，所有变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，程序运行过程中也不能改变变量的类型。</p></li><li><p><strong>变量名称</strong>：又称标识符，只能由字母、数字、下划线构成，数字不能出现在第一个位置。此外，Java 的保留字也不能用作标识符。</p></li><li><p>Java 的保留字列表</p></li></ul><table><thead><tr><th>abstract</th><th>do</th><th>implements</th><th>protected</th><th>throws</th></tr></thead><tbody><tr><td>boolean</td><td>double</td><td>import</td><td>public</td><td>transient</td></tr><tr><td>break</td><td>else</td><td>instanceof</td><td>return</td><td>true</td></tr><tr><td>byte</td><td>extends</td><td>int</td><td>short</td><td>try</td></tr><tr><td>case</td><td>false</td><td>interface</td><td>static</td><td>while</td></tr><tr><td>catch</td><td>final</td><td>long</td><td>strictfp</td><td>void</td></tr><tr><td>char</td><td>finally</td><td>native</td><td>super</td><td>volatile</td></tr><tr><td>class</td><td>float</td><td>new</td><td>switch</td></tr><tr><td>const*</td><td>for</td><td>null</td><td>synchronized</td></tr><tr><td>continue</td><td>goto*</td><td>package</td><td>this</td></tr><tr><td>default</td><td>if</td><td>private</td><td>throw</td></tr></tbody></table><ul class="task-list"><li>以下哪些标识符是符合规则的？</li><li class="task-list-item"><input type="checkbox" id="cbx_4" checked="true" disabled="true" /><label for="cbx_4"> currency</label></li><li class="task-list-item"><input type="checkbox" id="cbx_5" checked="true" disabled="true" /><label for="cbx_5"> lastName</label></li><li class="task-list-item"><input type="checkbox" id="cbx_6" checked="true" disabled="true" /><label for="cbx_6"> fireplace</label></li><li class="task-list-item"><input type="checkbox" id="cbx_7" disabled="true" /><label for="cbx_7"> _last_name</label></li><li class="task-list-item"><input type="checkbox" id="cbx_8" checked="true" disabled="true" /><label for="cbx_8"> xingmin</label></li><li class="task-list-item"><input type="checkbox" id="cbx_9" disabled="true" /><label for="cbx_9"> class</label></li><li class="task-list-item"><input type="checkbox" id="cbx_10" disabled="true" /><label for="cbx_10"> goto</label></li><li class="task-list-item"><input type="checkbox" id="cbx_11" disabled="true" /><label for="cbx_11"> 4ever</label></li><li class="task-list-item"><input type="checkbox" id="cbx_12" disabled="true" /><label for="cbx_12"> time-machine</label></li><li class="task-list-item"><input type="checkbox" id="cbx_13" disabled="true" /><label for="cbx_13"> Int</label></li><li class="task-list-item"><input type="checkbox" id="cbx_14" disabled="true" /><label for="cbx_14"> $12</label></li><li class="task-list-item"><input type="checkbox" id="cbx_15" disabled="true" /><label for="cbx_15"> 我是变量</label></li></ul><h2 id="常量-final"><a class="anchor" href="#常量-final">#</a> 常量 final</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">AMOUNT</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//final 是一个修饰符，表示这个变量的值一旦初始化，就不能再修改了。</span></pre></td></tr></table></figure><h2 id="变量类型"><a class="anchor" href="#变量类型">#</a> 变量类型</h2><h3 id="整数-int"><a class="anchor" href="#整数-int">#</a> 整数 int</h3><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> price <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>如果用户输入的不是整数，则会报错  <code>java.util.InputMismatchException</code> 。</li><li>程序要求读入多个数字时，可以在一行输入，中间用空格分开，也可以多行输入。</li><li>每次召唤 <code>in.nextInt()</code> ，它就等待用户输入一个整数。</li><li>两个整数的运算结果只能是整数。</li><li>在 Java 中， <code>10</code>  和 <code>10.0</code>  是完全不同的数。</li></ul><h3 id="浮点数-double"><a class="anchor" href="#浮点数-double">#</a> 浮点数 double</h3><ul><li><strong>浮点数运算有误差</strong>：由于二进制的自身限制，浮点计算需要将十进制先转换为二进制，然后对二进制数进行计算，因此导致误差。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1.2</span><span class="token operator">-</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 结果为 0.09999999999999987</span></pre></td></tr></table></figure><ul><li>整数类型不能表达有小数部分的数；整数运算速度快，占内存小；日常中整数运算多。</li></ul><h2 id="赋值运算"><a class="anchor" href="#赋值运算">#</a> 赋值运算</h2><h3 id="强制类型转换"><a class="anchor" href="#强制类型转换">#</a> 强制类型转换</h3><ul><li>浮点数和整数放在一起运算时，Java 会将整数转换成浮点数，然后进行浮点数运算。</li><li>强制性转换的优先级高于四则运算。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a<span class="token operator">/</span>b<span class="token punctuation">;</span> <span class="token comment">// 会报错</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不会报错</span></pre></td></tr></table></figure><h3 id="运算符优先级"><a class="anchor" href="#运算符优先级">#</a> 运算符优先级</h3><ul><li>单目运算符 <code>+</code>   <code>-</code>  优先级最高</li><li>结合关系一般自左向右，单目 <code>+</code>   <code>-</code>  和赋值 <code>=</code>  自右向左。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>result <span class="token operator">=</span> a <span class="token operator">=</span> b <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">+</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>result <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">=</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token punctuation">(</span>result <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="复合赋值"><a class="anchor" href="#复合赋值">#</a> 复合赋值</h3><ul><li>5 个算术运算符， <code>+ - * / %</code> ，可以和赋值运算符  <code>=</code>  结合起来，形成复合赋值运算。注意，两个运算符中间不要有空格。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>total <span class="token operator">+=</span> <span class="token punctuation">(</span>sum<span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token punctuation">(</span>sum<span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>total <span class="token operator">*</span> <span class="token operator">=</span> sum<span class="token operator">+</span><span class="token number">12</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>total <span class="token operator">=</span> total<span class="token operator">*</span><span class="token punctuation">(</span>sum<span class="token operator">+</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>total <span class="token operator">/=</span> <span class="token number">12</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>total <span class="token operator">=</span> total <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>递增递减运算符  <code>++</code>   <code>--</code> ，给变量 + 1 或 - 1</li><li>前缀后缀：</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>a <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>t1 <span class="token operator">=</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//t1 先被赋值为 a 即 14， a 自加到 15</span></pre></td></tr><tr><td data-num="3"></td><td><pre>t2 <span class="token operator">=</span> <span class="token operator">++</span>a<span class="token punctuation">;</span> <span class="token comment">//a 先自加到 15，t2 被赋值为 a 即 15</span></pre></td></tr></table></figure><h1 id="编程题"><a class="anchor" href="#编程题">#</a> 编程题</h1><h2 id="题目1-温度转换5分"><a class="anchor" href="#题目1-温度转换5分">#</a> 题目 1. 温度转换（5 分）</h2><ul><li><p><strong>题目内容</strong><br />写一个将华氏温度转换成摄氏温度的程序，转换的公式是：</p><p><code>°F = (9/5)*°C + 32</code></p><p>其中 C 表示摄氏温度，F 表示华氏温度。</p><p>程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。</p><p>提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式：</p><p><code>(int)x;</code></p><p>其中 x 是要转换的那个浮点数。</p><p><em>注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。这道题目要求转换后的数字，程序就只能输出这个数字，除此之外任何内容都不能输出。</em></p></li><li><p><strong>输入格式</strong><br />一个整数。</p></li><li><p><strong>输出格式</strong><br />一个整数。</p></li><li><p><strong>输入样例</strong><br /> 100</p></li><li><p><strong>输出样例</strong><br /> 37</p></li></ul><h3 id="解题代码"><a class="anchor" href="#解题代码">#</a> 解题代码</h3><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 获得输入的整数</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> fahrenheit <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 计算摄氏度</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">double</span> centigrade <span class="token operator">=</span> <span class="token punctuation">(</span>fahrenheit <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">/</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 将浮点数转换为整数输出</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>centigrade<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/14/hello-world/"/>
      <url>/2022/09/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo</span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting</span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub</span>.</p><h2 id="quick-start"><a class="anchor" href="#quick-start">#</a> Quick Start</h2><h3 id="create-a-new-post"><a class="anchor" href="#create-a-new-post">#</a> Create a new post</h3><figure class="highlight bash"><figcaption data-lang="bash"><span>h</span></figcaption><table><tr><td data-num="1"></td><td><pre>$ hexo new <span class="token string">"My New Post"</span></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing</span></p><h3 id="run-server"><a class="anchor" href="#run-server">#</a> Run server</h3><figure class="highlight bash"><figcaption data-lang="bash"><span>h</span></figcaption><table><tr><td data-num="1"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server</span></p><h3 id="generate-static-files"><a class="anchor" href="#generate-static-files">#</a> Generate static files</h3><figure class="highlight bash"><figcaption data-lang="bash"><span>h</span></figcaption><table><tr><td data-num="1"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating</span></p><h3 id="deploy-to-remote-sites"><a class="anchor" href="#deploy-to-remote-sites">#</a> Deploy to remote sites</h3><figure class="highlight bash"><figcaption data-lang="bash"><span>h</span></figcaption><table><tr><td data-num="1"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment</span><br />H<sub>2</sub>O<br />2<sup>10</sup></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
